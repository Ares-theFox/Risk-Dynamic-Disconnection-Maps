<!DOCTYPE html>
<html>
  <head>
    <title>Jules Verne's Mysterious Island</title>
    <style>
      #map,
      #range {
        position: absolute;
      }
      #range {
        z-index: 1;
      }
      header {
        font-size: 35px;
        font-weight: bold;
      }
      header img {
        vertical-align: bottom;
      }
      #fontSizeInput {
        width: 35px;
      }
    </style>
  </head>
  <body>
    <header>
	Jules Verne Dynamic Disconnection Map 
	<img src="" />
        <span id="invalidText" style="color: red; font-style: italic; font-size: 20px;"></span>
    </header>
<div>
  <button id="blizzardButton" onclick="button_AddBlizzards()">Add Blizzards</button>
  <button id="portalButton" onclick="button_AddPortals()">Add Portals</button>
  <button id="eraserButton" onclick="eraser()">Eraser</button>
  <button id="stopButton" onclick="button_StopEditing()">Stop Editing</button>
  <label for="fontSizeInput">Font Size:</label>
  <input type="number" id="fontSizeInput" name="fontSizeInput" value="30" min="1" max="100">
  <button id="resetButton">Reset Map</button>
  <button id="mapDirectoryButton">Map Directory</button>
</div>
	<style>
	/* Add some basic styles to the button */
	button {
	  font-size: 16px;
	  padding: 8px 16px;
	  border: none;
	  cursor: pointer;
	}
		
	#blizzardButton {
	  background-color: white;
	  color: black;
	}

	#blizzardButton:hover {
	  background-color: grey;
	}

	#portalButton {
	  background-color: aqua;
	  color: black;
	}

	#portalButton:hover {
	  background-color: navy;
	  color: white;
	}

	#eraserButton {
	background-color: #dd9d90;
	color: black;
	}

	#eraserButton:hover {
	background-color: #c89790;
	}
		
	#stopButton {
	background-color: #4caf50;
	color: white;
	}

	#stopButton:hover {
	background-color: #3e8e41;
	}

	#resetButton {
	background-color: grey;
	color: white;
	}

	#resetButton:hover {
	background-color: black;
	color: white;
	}

	#mapDirectoryButton {
	background-color: white;
	color: black;
	}

	#mapDirectoryButton:hover {
	background-color: grey;
	}
	</style>
	  
    <img
      id="map"
      src="https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne.PNG"
      alt="Jules Verne"
    />
    <div id="range"></div>
	  
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
<script>
  document.getElementById("resetButton").addEventListener("click", function () {
    location.reload();
  });

var images = [
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox1.PNG",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox2.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox3.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox4.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox5.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox6.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox7.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox8.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox9.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox10.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox11.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox12.png",
];

window.onload = function() {
  var img = document.querySelector("header img");
  var randomIndex = Math.floor(Math.random() * images.length);
  img.src = images[randomIndex];
};

// Define global variables
	console.log("thisisthelasttime")
	// Define map-specific items
	var colorLegend = "Jules%20Verne%20"
	var DirectConnections = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne%20CSV.csv"
	var IndirectConnections = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne%20Indirect%20Connection%20Locations%20CSV.csv"
	var SVG = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne%20Paths.svg"
	var BlizzardPattern = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne%20blizzard%20pattern.png"
	// Remember to change the img src and the alt title!!!!!!!!

	var totalBlizzards = 3
	var totalPortals = 5
	
	let blizzardArray = []
	let portalArray = []
	let clickedPathsBlizzardsPortals = []
	
	// Define connections tableData
	let tableData;
	let tableDataClone;
	let tableDataCloneCopy;
	Papa.parse(
	  DirectConnections,
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign parsed data to tableData
	      tableData = results.data;
	      // Remove zero-width space character from tableData
	      for (let i = 0; i < tableData.length; i++) {
		for (let key in tableData[i]) {
		  if (tableData[i].hasOwnProperty(key)) {
		    tableData[i][key] = tableData[i][key].replace(/\u200B/g, "");
		  }
		}
	      }
	      // Create a deep copy of tableData
	      tableDataClone = JSON.parse(JSON.stringify(tableData));
	    },
	  }
	);
	
	// Define color dictionaries 
	const colorDictionary = {
	  1: "#eb3337",
	  2: "#fd8238",
	  3: "#fdf12c",
	  4: "#2ed14f",
	  5: "#2ca9f1",
	  6: "#4a51cc",
	  7: "#b948ba",
	  8: "#8b2c32",
	  9: "#5f5f5f",
	 10: "#377a46",
	 11: "#460055",
	 12: "#161616"
	};
	const colorDarktionary = {
	 1: "#761a1c",
	 2: "#7f411c",
	 3: "#7f7916",
	 4: "#176928",
	 5: "#165579",
	 6: "#252966",
	 7: "#5d245d",
	 8: "#461619",
	 9: "#303030",
	10: "#1c3d23",
	11: "#23002b",
	12: "#000000"
	};
	
	// Define csvData as a global variable
	var csvData;

	Papa.parse(
	  IndirectConnections,
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign the parsed data to the global csvData variable
	      csvData = results.data;
	    }
	  }
	);
	
	// Map directory button
	var mapDirectoryButton = document.getElementById("mapDirectoryButton");
	mapDirectoryButton.addEventListener("click", function () {
	  window.location.href = "https://ares-thefox.github.io/Risk-Dynamic-Disconnection-Maps";
	});
	
// End of global variables

  // Load SVG
  let paths;
  let svgElement;
  var xhr = new XMLHttpRequest();
  xhr.open(
    "GET",
    SVG
  );
  xhr.onload = function () {
    if (xhr.status === 200) {
      var svg = xhr.responseText;
      var rangeElement = document.getElementById("range");
      rangeElement.innerHTML = svg;
      svgElement = rangeElement.querySelector("svg");
      paths = svgElement.querySelectorAll("path");
      paths.forEach(function (path) {
        path.setAttribute("fill", "transparent");
        path.setAttribute("stroke-opacity", "0");
      });
    generateMap();
    }
  };
  xhr.send();

// Stop editing
function stopEditing() {
	document.getElementById("stopButton").innerHTML = "Stop Editing";
	return;
}
	
// Generate the map
function generateMap() {
  // Update buttons
  updateButtonText();
  // Reset tableData to its original values
  tableData = JSON.parse(JSON.stringify(tableDataClone));
  // Remove existing text elements
  svgElement.querySelectorAll("text").forEach((text) => text.remove());
  // Remove everything contained in the blizzard array
	// Find rows in table data where column A matches values in blizzardArray
	const rows = tableData.filter((row) => blizzardArray.includes(row["A"]));

	// Remove everything in column B for those rows
	rows.forEach((row) => {
	  row["B"] = "";
	});

	// Remove all instances of values in blizzardArray from column B
	tableData.forEach((row) => {
	  if (row["B"]) {
	    // Split the value in column B into an array of values
	    let values = row["B"].split(",");
	    // Filter out any values that are included in the blizzardArray
	    values = values.filter((value) => !blizzardArray.includes(value));
	    // Join the remaining values back into a string and update the value in column B
	    row["B"] = values.join(",");
	  }
	});
  // Add everything contained in the portal array
	// Iterate over tableData
	tableData.forEach((row) => {
	  // Check if value in column A matches a value in portalArray
	  if (portalArray.includes(row["A"])) {
	    // Add contents of portalArray to column B
	    row["B"] = [
	      ...new Set([
		...(row["B"] ? row["B"].split(",") : []),
		...portalArray,
	      ]),
	    ]
	      .filter((value) => value !== row["A"])
	      .join(",");
	  }
	});
  // Recalculate columns L through P for all rows
  tableData.forEach((row) => {
    // Column M: vlookup col B values and add them + current value A and B
    row["M"] = ""; // initialize column M to blank
    if (row["B"] && row["B"].trim() !== "") {
      // check if column B is not empty or undefined
      const searchValues = row["B"].split(",");
      let searchResults = [];
      for (const searchValue of searchValues) {
        const trimmedSearchValue = searchValue.trim().replace(/\u200B/g, "");
        for (let i = 0; i < tableData.length; i++) {
          if (tableData[i]["A"] === trimmedSearchValue) {
            searchResults.push(tableData[i]["B"]);
            break;
          }
        }
      }
      row["M"] = [row["A"], row["B"], ...searchResults].join(",");
    }

    // Column N: Remove duplicate values from column M
    row["N"] = [...new Set(row["M"].split(","))]
      .filter((value) => value !== row["A"])
      .join(",");
	  
    // Column O: Count how many comma-separated values are in column B
    if (row["B"] && row["B"].trim() !== "") {
      // check if column B is not empty or undefined
      const values = row["B"].split(",");
      row["O"] = values.length;
    } else {
      row["O"] = 0;
    }

    // Column P: Count how many comma-separated values are in column N (unless it's empty, then set it to 0)
    if (row["N"] && row["N"].trim() !== "") {
      // check if column N is not empty or undefined
      const values = row["N"].split(",");
      row["P"] = values.length;
    } else {
      row["P"] = 0;
    }
  });

  // Set font size of indirect connections
  var fontSizeInput = document.getElementById("fontSizeInput");
  fontSizeInput.addEventListener("input", function () {
    if (this.value > 100) {
      this.value = 100;
    } else if (this.value < 1) {
      this.value = 1;
    }
  });
  fontSizeInput.addEventListener("input", function() {
    debouncedGenerateMap();
  });

  // Color in the map and add indirect connections
  paths.forEach(function (path) {
    var pathId = path.getAttribute("id");
    for (var i = 0; i < tableData.length; i++) {
      if (tableData[i]["A"] === pathId) {
        // Color in the map
        var value = tableData[i]["O"];
        if (value >= 12) {
          value = 12;
        }
        if (value !== 0) {
          var color = colorDictionary[value];
          var border_color = colorDarktionary[value];
          path.style.setProperty("fill", color, "important");
          path.setAttribute("stroke-opacity", "100");
          path.style.setProperty("stroke", border_color, "important");
          path.style.setProperty("stroke-width", "2", "important");
        }

        // Add text to the specified location from CSV data
        value = tableData[i]["P"];
        if (value !== 0) {
          // Find matching row in CSV data
          var csvRow = csvData.find(function (row) {
            return row["Range"] === pathId;
          });

          // Get coordinates from CSV data
          var x = csvRow["Pixel Pair 1"];
          var y = csvRow["Pixel Pair 2"];

          var text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          text.setAttribute("x", x);
          text.setAttribute("y", y);
	  text.setAttribute("pointer-events", "none");
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("alignment-baseline", "middle");
          text.setAttribute("font-size", fontSizeInput.value);
          text.setAttribute("font-weight", "bold");
	  if (tableData[i]["O"] >= 11) {
	    text.setAttribute("fill", "white");
	  } else {
	    text.setAttribute("fill", "black");
	  }
          text.textContent = value;

          // Adjust x and y coordinates to position midpoint of text at specified coordinates
          var bbox = text.getBBox();
          text.setAttribute("x", x - bbox.width / 2);
          text.setAttribute("y", y - bbox.height / 2);

          svgElement.appendChild(text);
        }
        break;
      }
    }
  });
	// Find the maximum value in column O
	var maxO = Math.max(...tableData.map((row) => row["O"]));

	// Ensure that maxO is never greater than 12
	if (maxO > 12) {
	  maxO = 12;
	}
	// Get the base image element & define base URL
	var baseImage = document.getElementById("map");
	var baseURL = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/";

	// Decide which image to display based on the maximum value in column O
	baseImage.src = baseURL + colorLegend + maxO + ".png";

// Create a mapping of node names to indices
let nodeToIndex = {};
let index = 0;
tableData.forEach(row => {
  if (row['A'] && !nodeToIndex.hasOwnProperty(row['A'])) {
    nodeToIndex[row['A']] = index++;
  }
  let neighbors = row['B'] ? row['B'].split(',') : [];
  neighbors.forEach(neighbor => {
    if (!nodeToIndex.hasOwnProperty(neighbor)) {
      nodeToIndex[neighbor] = index++;
    }
  });
});

// Create a distance matrix with dimensions equal to the number of nodes
let dist = new Array(index);
for (let i = 0; i < index; i++) {
  dist[i] = new Array(index);
  for (let j = 0; j < index; j++) {
    if (i === j) {
      dist[i][j] = 0;
    } else {
      dist[i][j] = Infinity;
    }
  }
}

// Populate the distance matrix with the distances between directly connected nodes
tableData.forEach(row => {
  let x = nodeToIndex[row['A']];
  let neighbors = row['B'] ? row['B'].split(',') : [];
  neighbors.forEach(neighbor => {
    let y = nodeToIndex[neighbor];
    dist[x][y] = 1;
    dist[y][x] = 1;
  });
});

// Run the Floyd-Warshall algorithm
for (let k = 0; k < index; k++) {
  for (let i = 0; i < index; i++) {
    for (let j = 0; j < index; j++) {
      if (dist[i][k] + dist[k][j] < dist[i][j]) {
        dist[i][j] = dist[i][k] + dist[k][j];
      }
    }
  }
}

// Check if there are any pairs of nodes that are not connected
let allNodesConnected = true;
for (let i = 0; i < index; i++) {
  for (let j = i + 1; j < index; j++) {
    // Get the node names corresponding to indices i and j
    let node1 = Object.keys(nodeToIndex).find(key => nodeToIndex[key] === i);
    let node2 = Object.keys(nodeToIndex).find(key => nodeToIndex[key] === j);
    // Check if either node is in the blizzardArray
    if (!blizzardArray.includes(node1) && !blizzardArray.includes(node2)) {
      // Check if the distance between the nodes is Infinity
      if (dist[i][j] === Infinity) {
        allNodesConnected = false;
        break;
      }
    }
  }
}

// Reset tableDataCloneCopy to its original state
tableDataCloneCopy = JSON.parse(JSON.stringify(tableDataClone));

// Add everything contained in the portal array to tableDataCloneCopy
// Iterate over tableDataCloneCopy
tableDataCloneCopy.forEach((row) => {
  // Check if value in column A matches a value in portalArray
  if (portalArray.includes(row["A"])) {
    // Add contents of portalArray to column B
    row["B"] = [
      ...new Set([
        ...(row["B"] ? row["B"].split(",") : []),
        ...portalArray,
      ]),
    ]
      .filter((value) => value !== row["A"])
      .join(",");
  }
});

// Create a mapping of node names to indices for tableDataCloneCopy
let nodeToIndexClone = {};
let indexClone = 0;
tableDataCloneCopy.forEach(row => {
  if (row['A'] && !nodeToIndexClone.hasOwnProperty(row['A'])) {
    nodeToIndexClone[row['A']] = indexClone++;
  }
  let neighbors = row['B'] ? row['B'].split(',') : [];
  neighbors.forEach(neighbor => {
    if (!nodeToIndexClone.hasOwnProperty(neighbor)) {
      nodeToIndexClone[neighbor] = indexClone++;
    }
  });
});

// Create a distance matrix with dimensions equal to the number of nodes for tableDataCloneCopy
let distClone = new Array(indexClone);
for (let i = 0; i < indexClone; i++) {
  distClone[i] = new Array(indexClone);
  for (let j = 0; j < indexClone; j++) {
    if (i === j) {
      distClone[i][j] = 0;
    } else {
      distClone[i][j] = Infinity;
    }
  }
}

// Populate the distance matrix with the distances between directly connected nodes for tableDataCloneCopy
tableDataCloneCopy.forEach(row => {
  let x = nodeToIndexClone[row['A']];
  let neighbors = row['B'] ? row['B'].split(',') : [];
  neighbors.forEach(neighbor => {
    let y = nodeToIndexClone[neighbor];
    distClone[x][y] = 1;
    distClone[y][x] = 1;
  });
});

// Run the Floyd-Warshall algorithm for tableDataCloneCopy
for (let k = 0; k < indexClone; k++) {
  for (let i = 0; i < indexClone; i++) {
    for (let j = 0; j < indexClone; j++) {
      if (distClone[i][k] + distClone[k][j] < distClone[i][j]) {
        distClone[i][j] = distClone[i][k] + distClone[k][j];
      }
    }
  }
}

// Check if any pair of portal nodes are within 2 travel distance of each other
let portalsTooClose = false;
for (let i = 0; i < portalArray.length; i++) {
  for (let j = i + 1; j < portalArray.length; j++) {
    // Get the node names corresponding to indices i and j
    let node1 = portalArray[i];
    let node2 = portalArray[j];
    // Get the indices corresponding to the node names
    let x = nodeToIndexClone[node1];
    let y = nodeToIndexClone[node2];
    // Check if the distance between the nodes is less than or equal to 2
    if (distClone[x][y] <= 2) {
      portalsTooClose = true;
      break;
    }
  }
}

// Update invalid text
var invalidText = document.getElementById("invalidText");
if (!allNodesConnected && portalsTooClose) {
  invalidText.textContent = "Invalid Generation: Map disconnected; Portals too close";
} else if (!allNodesConnected) {
  invalidText.textContent = "Invalid Generation: Map is disconnected";
} else if (portalsTooClose) {
  invalidText.textContent = "Invalid Generation: Portals are too close";
} else {
  invalidText.textContent = "";
}

}
	
function debounce(func, wait) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, arguments), wait);
  };
}

const debouncedGenerateMap = debounce(generateMap, 500);

function addBlizzards() {
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Adding Blizzards";

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

  // Check if size of blizzardArray is greater than or equal to totalBlizzards
  if (blizzardArray.length >= totalBlizzards) {
    // Return early from the function
    return;
  }
  // Define mouseover, mouseout, and click event handlers
  const mouseoverHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
      // Store original stroke color and width in custom attributes
      this.setAttribute("data-stroke", this.style.stroke);
      this.setAttribute("data-stroke-width", this.style.strokeWidth);
      // Change stroke color to white and stroke width to 3
      this.style.setProperty("stroke", "white", "important");
      this.style.setProperty("stroke-width", "3", "important");
    }
  };
  const mouseoutHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Reset stroke color and width to original values
    this.style.setProperty("stroke", this.getAttribute("data-stroke"), "important");
    this.style.setProperty("stroke-width", this.getAttribute("data-stroke-width"), "important");
  };
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	// Create a clipPath element and set its id
	var clipPath = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "clipPath"
	);
	clipPath.setAttribute("id", "clip-" + this.id);

	// Clone the clicked path and append it to the clipPath
	var clonedPath = this.cloneNode(true);
	clipPath.appendChild(clonedPath);

	// Append the clipPath to the defs element
	var defs =
	  svgElement.querySelector("defs") ||
	  svgElement.insertBefore(
	    document.createElementNS("http://www.w3.org/2000/svg", "defs"),
	    svgElement.firstChild
	  );
	defs.appendChild(clipPath);

	// Create an image element and set its attributes
	var image = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "image"
	);
	image.setAttributeNS(
	  "http://www.w3.org/1999/xlink",
	  "href",
	  BlizzardPattern
	);
	image.setAttribute("width", "100%");
	image.setAttribute("height", "100%");
	image.setAttribute("clip-path", "url(#clip-" + this.id + ")");
	image.setAttribute("pointer-events", "none");

	// Append the image to the SVG
	svgElement.appendChild(image);

	// Move the image behind the path element
	svgElement.insertBefore(image, svgElement.firstChild);
	    
    // Add clicked path to blizzardArray and clickedPathsBlizzardsPortals array
    blizzardArray.push(this.id);
    clickedPathsBlizzardsPortals.push(this.id);

    // Change the fill of the clicked path to transparent
    this.style.setProperty("fill", "transparent", "important");

    // Change stroke color and stroke width
    this.style.setProperty("stroke", "white", "important");
    this.style.setProperty("stroke-width", "1", "important");
    this.removeEventListener("mouseout", mouseoutHandler);
	    
    // Check if size of blizzardArray is greater than or equal to totalBlizzards
    if (blizzardArray.length >= totalBlizzards) {
      // Remove existing event listeners from elements in paths array
      paths.forEach(function (path) {
        path.removeEventListener("mouseover", mouseoverHandler);
        path.removeEventListener("mouseout", mouseoutHandler);
        path.removeEventListener("click", clickHandler);
      });
      document.getElementById("stopButton").innerHTML = "Stop Editing";
      generateMap();
      return;
    }

    // Execute generateMap function
    generateMap();
    }
    };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}  

function addPortals() {
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Adding Portals";

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

  // Check if size of portalArray is greater than or equal to totalPortals
  if (portalArray.length >= totalPortals) {
    // Return early from the function
    return;
  }
  // Define mouseover, mouseout, and click event handlers
  const mouseoverHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
      // Store original stroke color and width in custom attributes
      this.setAttribute("data-stroke", this.style.stroke);
      this.setAttribute("data-stroke-width", this.style.strokeWidth);
      // Change stroke color to white and stroke width to 3
      this.style.setProperty("stroke", "white", "important");
      this.style.setProperty("stroke-width", "3", "important");
    }
  };
  const mouseoutHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Reset stroke color and width to original values
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
    this.style.setProperty("stroke", this.getAttribute("data-stroke"), "important");
    this.style.setProperty("stroke-width", this.getAttribute("data-stroke-width"), "important");
    }
  };
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	// Create an image element and set its attributes
	var image = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "image"
	);
	image.setAttributeNS(
	  "http://www.w3.org/1999/xlink",
	  "href",
	  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/portal.png"
	);

	// Set a custom attribute to store the id of the clicked path
	image.setAttribute("data-path-id", this.id);

	// Store the value of this.id in a variable
	var pathId = this.id;

	// Find matching row in CSV data
	var csvRow = csvData.find(function (row) {
	  return row["Range"] === pathId;
	});

      // Get coordinates from CSV data
      var x = csvRow["Pixel Pair 1"];
      var y = csvRow["Pixel Pair 2"];

      // Set pointer-events attribute of the image element to none
      image.setAttribute("pointer-events", "none");

      // Append the image to the SVG
      svgElement.appendChild(image);

      // Add an event listener to the image element to update its x and y attributes after it has been loaded
      image.addEventListener("load", function() {
        // Get the bounding box of the image element
        var bbox = image.getBBox();

        // Update the x and y attributes of the image element to center it over the clicked area
        image.setAttribute("x", x - bbox.width / 2);
        image.setAttribute("y", y - bbox.height / 2);

        // Rotate the image a random number of degrees between 0 and 359 around its center point
        var angle = Math.floor(Math.random() * 360);
        var cx = x;
        var cy = y;
        image.setAttribute(
          "transform",
          "rotate(" + angle + " " + cx + " " + cy + ")"
        );
      });

      // Add clicked path to portalArray and clickedPathsBlizzardsPortals array
      portalArray.push(this.id);
      clickedPathsBlizzardsPortals.push(this.id);

       // Check if size of blizzardArray is greater than or equal to totalBlizzards
       if (portalArray.length >= totalPortals) {
         // Remove existing event listeners from elements in paths array
         paths.forEach(function (path) {
           path.removeEventListener("mouseover", mouseoverHandler);
           path.removeEventListener("mouseout", mouseoutHandler);
           path.removeEventListener("click", clickHandler);
         });
     	       document.getElementById("stopButton").innerHTML = "Stop Editing";
	       generateMap();
	       return;
       }

       // Execute generateMap function
       generateMap();
    }
  };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });

}

function button_StopEditing() {
  stopEditing();
}
	
function button_AddBlizzards() {
  addBlizzards();
}

function button_AddPortals() {
  addPortals();
}
	
function eraser() {
  // Immediately return if the size of the clickedPathsBlizzardsPortals array is empty
  if (clickedPathsBlizzardsPortals.length === 0) {
    return;
  }
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Erasing";

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

  // Define mouseover, mouseout, and click event handlers
  const mouseoverHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is in clickedPathsBlizzardsPortals array
    if (clickedPathsBlizzardsPortals.includes(this.id)) {
      // Check if data-stroke and data-stroke-width attributes already exist
      if (!this.hasAttribute("data-stroke") && !this.hasAttribute("data-stroke-width")) {
        // Store original stroke color and width in custom attributes
        this.setAttribute("data-stroke", this.style.stroke);
        this.setAttribute("data-stroke-width", this.style.strokeWidth);
      }
      // Change stroke color to #ff1111 and stroke width to 4
      this.style.setProperty("stroke", "#ff1111", "important");
      this.style.setProperty("stroke-width", "4", "important");
    }
  };
  const mouseoutHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Reset stroke color and width to original values
    if (clickedPathsBlizzardsPortals.includes(this.id)) {
      if (blizzardArray.includes(this.id)) {
        this.style.setProperty("stroke", "white", "important");
        this.style.setProperty("stroke-width", "1", "important");
      } else {
        this.style.setProperty("stroke", this.getAttribute("data-stroke"), "important");
        this.style.setProperty("stroke-width", this.getAttribute("data-stroke-width"), "important");
      }
    }
  };
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is in clickedPathsBlizzardsPortals array
    if (clickedPathsBlizzardsPortals.includes(this.id)) {
      // Remove clicked path from clickedPathsBlizzardsPortals array
      clickedPathsBlizzardsPortals = clickedPathsBlizzardsPortals.filter(
        (path) => path !== this.id
      );

      // Check if path is in blizzardArray
      if (blizzardArray.includes(this.id)) {
        // Remove clicked path from blizzardArray
        blizzardArray = blizzardArray.filter((path) => path !== this.id);

        // Remove blizzard fill from clicked path
        var clipPathId = "blizzard-clip-" + this.id;
        var clipPath = document.getElementById(clipPathId);
        if (clipPath) {
          clipPath.remove();
        }
      }

      // Check if path is in portalArray
      if (portalArray.includes(this.id)) {
        // Remove clicked path from portalArray
        portalArray = portalArray.filter((path) => path !== this.id);

        // Store the value of this.id in a variable
        var clickedPathId = this.id;

        // Remove portal image overlay from clicked path
        var images = svgElement.querySelectorAll("image");
        images.forEach(function (image) {
          // Check if the data-path-id attribute of the image matches the id of the clicked path
          if (image.getAttribute("data-path-id") === clickedPathId) {
            // Remove the image
            image.remove();
          }
        });
      }

      // Call generateMap function
      generateMap();

      // Check if clickedPathsBlizzardsPortals array is empty
      if (clickedPathsBlizzardsPortals.length === 0) {
	document.getElementById("stopButton").innerHTML = "Stop Editing";
        return;
      }
    }
  };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}

// Update button text on page load
updateButtonText();

function updateButtonText() {
    // Update "Add Blizzards" button text
    if (totalBlizzards - blizzardArray.length <= 0) {
        document.getElementById("blizzardButton").innerHTML = "Added all Blizzards";
    } else {
        document.getElementById("blizzardButton").innerHTML = "Add Blizzards (" + (totalBlizzards - blizzardArray.length) + " left)";
    }

    // Update "Add Portals" button text
    if (totalPortals - portalArray.length <= 0) {
        document.getElementById("portalButton").innerHTML = "Added all Portals";
    } else {
        document.getElementById("portalButton").innerHTML = "Add Portals (" + (totalPortals - portalArray.length) + " left)";
    }
}
</script>
</body>
</html>
