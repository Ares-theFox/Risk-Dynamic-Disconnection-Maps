<!DOCTYPE html>
<html>
  <head>
    <title>Jules Verne's Mysterious Island</title>
    <style>
      #map,
      #range {
        position: absolute;
      }
      #range {
        z-index: 1;
      }
      header {
        font-size: 35px;
        font-weight: bold;
      }
    </style>
  </head>
  <body>	  
    <header>Ares' Jules Verne Dynamic Disconnection Map</header>
<div>
  <button id="button1" onclick="button_GenerateMap()">Generate Map</button>
  <button id="button2" onclick="button_AddBlizzards()">Add Blizzards</button>
  <button id="button3" onclick="button_AddPortals()">Add Portals</button>
</div>	  
	<style>
	/* Add some basic styles to the button */
	button {
	  font-size: 16px;
	  padding: 8px 16px;
	  border: none;
	  cursor: pointer;
	}

	#button1 {
	  background-color: #4caf50;
	  color: white;
	}

	#button1:hover {
	  background-color: #3e8e41;
	  color: white;
	}

	#button2 {
	  background-color: white;
	  color: black;
	}

	#button2:hover {
	  background-color: grey;
	}

	#button2:disabled:hover {
	  background-color: white;
	}

	#button3 {
	  background-color: aqua;
	  color: black;
	}

	#button3:hover {
	  background-color: navy;
	  color: white;
	}

	#button3:disabled:hover {
	  background-color: aqua;
	}
	</style>
	  
    <img
      id="map"
      src="https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne.PNG"
      alt="Map of United States"
    />
    <div id="range"></div>
	  
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
	  
<script>
// Define global variables
	// Define blizzard/portal clicks
		var blizzardClickCounter = 0
		var blizzardClickCounterMax = 3
		var portalClickCounter = 0
		var portalClickCounterMax = 5
	// Define connections tableData
	let tableData;
	Papa.parse(
	"https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne%20CSV.csv",
	{
	  download: true,
	  header: true,
	  complete: function (results) {
	    // Assign parsed data to tableData
	    tableData = results.data;
	    // Remove zero-width space character from tableData
	    for (let i = 0; i < tableData.length; i++) {
	      for (let key in tableData[i]) {
		if (tableData[i].hasOwnProperty(key)) {
		  tableData[i][key] = tableData[i][key].replace(/\u200B/g, "");
		  }
		}
	      }
	      console.log(tableData);
	    },
	  }
	);

	// Define color dictionaries 
	const colorDictionary = {
	1: "#ec1c24",
	2: "#ff7f27",
	3: "#fff200",
	4: "#0ed145",
	5: "#00a8f3",
	6: "#3f48cc",
	7: "#b83dba",
	8: "#b97a56",
	9: "#585858",
	10: "#38784a",
	11: "#ffaec8",
	12: "#ffffff"
	};
	const colorDarktionary = {
	1: "#760E12",
	2: "#804014",
	3: "#807900",
	4: "#076923",
	5: "#00547A",
	6: "#101233",
	7: "#5C1F5D",
	8: "#5D3D2B",
	9: "#2C2C2C",
	10: "#1C3C25",
	11: "#805764",
	12: "#808080"
	};
	
	// Define csvData as a global variable
	var csvData;

	Papa.parse(
	  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne%20Indirect%20Connection%20Locations%20CSV.csv",
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign the parsed data to the global csvData variable
	      csvData = results.data;
	    }
	  }
	);
	
// End of global variables
</script>

<script>
  // Load SVG
  let paths;
  let svgElement;
  var xhr = new XMLHttpRequest();
  xhr.open(
    "GET",
    "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne%20Paths.svg"
  );
  xhr.onload = function () {
    if (xhr.status === 200) {
      var svg = xhr.responseText;
      var rangeElement = document.getElementById("range");
      rangeElement.innerHTML = svg;
      svgElement = rangeElement.querySelector("svg");
      paths = svgElement.querySelectorAll("path");
      paths.forEach(function (path) {
        path.setAttribute("fill", "transparent");
        path.setAttribute("stroke-opacity", "0");
      });
    }
  };
  xhr.send();
</script>

<script>
// Add blizzards
function addBlizzards() {
  var mouseoverHandler = function () {
    if (blizzardClickCounter < blizzardClickCounterMax) {
      this.style.fill = "white";
    }
  };
  var mouseoutHandler = function () {
    this.style.fill = "transparent";
  };
  paths.forEach(function(path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
  });
  let clickedPaths = [];
  paths.forEach(function(path) {
    path.addEventListener("click", function() {
      // Check if blizzardClickCounter is less than blizzardClickCounterMax
      if (blizzardClickCounter >= blizzardClickCounterMax) {
        // If it is not, return early from the function
        return;
      }

      // Log clicked path ID to console
      console.log(this.id);

      // Check if clickCounter is less than Max
      if (blizzardClickCounter < blizzardClickCounterMax) {
        // Create a clipPath element and set its id
        var clipPath = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "clipPath"
        );
        clipPath.setAttribute("id", "clip-" + this.id);

        // Clone the clicked path and append it to the clipPath
        var clonedPath = this.cloneNode(true);
        clipPath.appendChild(clonedPath);

        // Append the clipPath to the defs element
        var defs =
          svgElement.querySelector("defs") ||
          svgElement.insertBefore(
            document.createElementNS("http://www.w3.org/2000/svg", "defs"),
            svgElement.firstChild
          );
        defs.appendChild(clipPath);

        // Create an image element and set its attributes
        var image = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "image"
        );
        image.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "href",
          "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Jules%20Verne%20blizzard%20pattern.png"
        );
        image.setAttribute("width", "100%");
        image.setAttribute("height", "100%");
        image.setAttribute("clip-path", "url(#clip-" + this.id + ")");

        // Append the image to the SVG
        svgElement.appendChild(image);
        console.log(blizzardClickCounter);

        // Remove mouseover and mouseout event listeners
        this.removeEventListener("mouseover", mouseoverHandler);
        this.removeEventListener("mouseout", mouseoutHandler);
      }

      // Increment the click counter and push value to clickedPaths array
      blizzardClickCounter++;
      clickedPaths.push(this.id);

      // Find rows in table data where column A matches clicked path's ID
      const rows = tableData.filter((row) => clickedPaths.includes(row["A"]));

      // Find the row in table data where column A matches clicked path's ID
      const row = tableData.find((row) => row["A"] === this.id);

      // Remove everything in column B for that row
      if (row) {
        row["B"] = "";
      }

      // Remove all instances of clicked path's ID from column B
      tableData.forEach((row) => {
        if (row["B"]) {
          // Split the value in column B into an array of values
          let values = row["B"].split(",");
          // Filter out any values that are included in the clickedPaths array
          values = values.filter((value) => !clickedPaths.includes(value));
          // Join the remaining values back into a string and update the value in column B
          row["B"] = values.join(",");
        }
      });

      if (blizzardClickCounter === blizzardClickCounterMax) {
        document.getElementById('button1').disabled = false;
        document.getElementById('button3').disabled = false;
      }
      // Update button text after each click
      updateButtonText();
    });
  });
}
</script>
	
<script>
function addPortals() {
  var mouseoverHandler = function () {
    if (portalClickCounter < portalClickCounterMax) {
      this.style.fill = "white";
    }
  };
  var mouseoutHandler = function () {
    this.style.fill = "transparent";
  };
  paths.forEach(function(path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
  });
  let clickedPaths = [];
  paths.forEach(function(path) {
    path.addEventListener("click", function() {
      // Check if portalClickCounter is less than portalClickCounterMax
      if (portalClickCounter >= portalClickCounterMax) {
        // If it is not, return early from the function
        return;
      }

      // Log clicked path ID to console
      console.log(this.id);

      // Check if clickCounter is less than Max
      if (portalClickCounter < portalClickCounterMax) {
        // Create an image element and set its attributes
        var image = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "image"
        );
        image.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "href",
          "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/portal.png"
        );

        // Store the value of this.id in a variable
        var pathId = this.id;

        // Find matching row in CSV data
        var csvRow = csvData.find(function (row) {
          return row["Range"] === pathId;
        });

        // Get coordinates from CSV data
        var x = csvRow["Pixel Pair 1"];
        var y = csvRow["Pixel Pair 2"];

        // Set x and y attributes of the image element
        image.setAttribute("x", x);
        image.setAttribute("y", y);

        // Append the image to the SVG
        svgElement.appendChild(image);

        // Remove mouseover and mouseout event listeners from clicked path
        this.removeEventListener("mouseover", mouseoverHandler);
        this.removeEventListener("mouseout", mouseoutHandler);
      }

      // Increment the click counter and push value to clickedPaths array
      portalClickCounter++;
      clickedPaths.push(this.id);

      if (portalClickCounter === portalClickCounterMax) {
        document.getElementById('button1').disabled = false;
        document.getElementById('button2').disabled = false;
      }
      // Update button text after each click
      updateButtonText();
    });
  });
}
</script>
	  
<script>
// Generate the map
function generateMap() {
  paths.forEach(function (path) {
    var clone = path.cloneNode(true);
    path.parentNode.replaceChild(clone, path);
  });

  // Recalculate columns L through P for all rows
  tableData.forEach((row) => {
    // Column M: vlookup col B values and add them + current value A and B
    row["M"] = ""; // initialize column M to blank
    if (row["B"] && row["B"].trim() !== "") {
      // check if column B is not empty or undefined
      const searchValues = row["B"].split(",");
      let searchResults = [];
      for (const searchValue of searchValues) {
        const trimmedSearchValue = searchValue.trim().replace(/\u200B/g, "");
        for (let i = 0; i < tableData.length; i++) {
          if (tableData[i]["A"] === trimmedSearchValue) {
            searchResults.push(tableData[i]["B"]);
            break;
          }
        }
      }
      row["M"] = [row["A"], row["B"], ...searchResults].join(",");
    }

    // Column N: Remove duplicate values from column M
    row["N"] = [...new Set(row["M"].split(","))].join(",");

    // Column O: Count how many comma-separated values are in column B
    if (row["B"] && row["B"].trim() !== "") {
      // check if column B is not empty or undefined
      const values = row["B"].split(",");
      row["O"] = values.length;
    } else {
      row["O"] = 0;
    }

    // Column P: Count how many comma-separated values are in column N (unless it's empty, then set it to "")
    if (row["N"] && row["N"].trim() !== "") {
      // check if column N is not empty or undefined
      const values = row["N"].split(",");
      row["P"] = values.length - 1;
    } else {
      row["P"] = 0;
    }
  });

  // Log updated table data to console
  console.log(tableData);

  // Update the paths variable to reference the cloned paths
  paths = svgElement.querySelectorAll("path");

  // Set font size of indirect connections
  var fontSize = 30;

  // Color in the map and add indirect connections
  paths.forEach(function (path) {
    var pathId = path.getAttribute("id");
    for (var i = 0; i < tableData.length; i++) {
      if (tableData[i]["A"] === pathId) {
        // Color in the map
        var value = tableData[i]["O"];
        if (value !== 0) {
          var color = colorDictionary[value];
          var border_color = colorDarktionary[value];
          path.style.setProperty("fill", color, "important");
          path.setAttribute("stroke-opacity", "100");
          path.style.setProperty("stroke", border_color, "important");
          path.style.setProperty("stroke-width", "2", "important");
        }

        // Add text to the specified location from CSV data
        value = tableData[i]["P"];
        if (value !== 0) {
          // Find matching row in CSV data
          var csvRow = csvData.find(function (row) {
            return row["Range"] === pathId;
          });

          // Get coordinates from CSV data
          var x = csvRow["Pixel Pair 1"];
          var y = csvRow["Pixel Pair 2"];

          var text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          text.setAttribute("x", x);
          text.setAttribute("y", y);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("alignment-baseline", "middle");
          text.setAttribute("font-size", fontSize);
          text.setAttribute("font-weight", "bold");
          text.textContent = value;

          // Adjust x and y coordinates to position midpoint of text at specified coordinates
          var bbox = text.getBBox();
          text.setAttribute("x", x - bbox.width / 2);
          text.setAttribute("y", y - bbox.height / 2);

          svgElement.appendChild(text);
        }
        break;
      }
    }
  });
}
</script>
  
<script>
  var button_GenerateMap_clicked = false;
  var button_AddBlizzards_clicked = false;
  var button_AddPortals_clicked = false;
  function button_GenerateMap() {
    if (!button_GenerateMap_clicked) {
      button_GenerateMap_clicked = true;
      generateMap();
    }
  }
  function button_AddBlizzards() {
    if (!button_AddBlizzards_clicked && !button_GenerateMap_clicked) {
      button_AddBlizzards_clicked = true;
      addBlizzards();
      document.getElementById('button1').disabled = true;
      document.getElementById('button3').disabled = true;
    }
  }
  function button_AddPortals() {
    if (!button_AddPortals_clicked && !button_GenerateMap_clicked) {
      button_AddPortals_clicked = true;
      addPortals();
      document.getElementById('button1').disabled = true;
      document.getElementById('button2').disabled = true;
    }
  }
</script>

<script>
// Update button text on page load
updateButtonText();

function updateButtonText() {
    // Update "Add Blizzards" button text
    if (blizzardClickCounterMax - blizzardClickCounter <= 0) {
        document.getElementById("button2").innerHTML = "Added all Blizzards";
    } else {
        document.getElementById("button2").innerHTML = "Add Blizzards (" + (blizzardClickCounterMax - blizzardClickCounter) + " left)";
    }

    // Update "Add Portals" button text
    if (portalClickCounterMax - portalClickCounter <= 0) {
        document.getElementById("button3").innerHTML = "Added all Portals";
    } else {
        document.getElementById("button3").innerHTML = "Add Portals (" + (portalClickCounterMax - portalClickCounter) + " left)";
    }
}
</script>
</body>
</html>
