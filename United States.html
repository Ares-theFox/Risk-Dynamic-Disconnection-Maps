<!DOCTYPE html>
<html>
  <head>
    <title>United States</title>
    <style>
      #map,
      #range {
        position: absolute;
      }
      #range {
        z-index: 1;
      }
      header {
        font-size: 35px;
        font-weight: bold;
      }
      header img {
        vertical-align: bottom;
      }
    </style>
  </head>
  <body>	  
    <header>
	United States Dynamic Disconnection Map 
	<img src="" />
    </header>
<div>
  <button id="button1" onclick="button_GenerateMap()">Generate Map</button>
  <button id="button2" onclick="button_AddBlizzards()">Add Blizzards</button>
  <button id="button3" onclick="button_AddPortals()">Add Portals</button>
</div>
<script>
var images = [
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox1.PNG",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox2.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox3.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox4.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox5.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox6.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox7.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox8.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox9.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox10.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox11.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox12.png",
];

window.onload = function() {
  var img = document.querySelector("header img");
  var randomIndex = Math.floor(Math.random() * images.length);
  img.src = images[randomIndex];
};
</script>
	<style>
	/* Add some basic styles to the button */
	button {
	  font-size: 16px;
	  padding: 8px 16px;
	  border: none;
	  cursor: pointer;
	}

	#button1 {
	  background-color: #4caf50;
	  color: white;
	}

	#button1:hover {
	  background-color: #3e8e41;
	  color: white;
	}

	#button2 {
	  background-color: white;
	  color: black;
	}

	#button2:hover {
	  background-color: grey;
	}

	#button2:disabled:hover {
	  background-color: white;
	}

	#button3 {
	  background-color: aqua;
	  color: black;
	}

	#button3:hover {
	  background-color: navy;
	  color: white;
	}

	#button3:disabled:hover {
	  background-color: aqua;
	}
	</style>
	  
    <img
      id="map"
      src="https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States.PNG"
      alt="United States"
    />
    <div id="range"></div>
	  
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
	  
<script>
// Define global variables
	// Define map-specific items
	var DirectConnections = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States%20CSV.csv"
	var IndirectConnections = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States%20Indirect%20Connection%20Locations%20CSV.csv"
	var SVG = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States%20Paths.svg"
	var BlizzardPattern = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/United%20States%20blizzard%20pattern.png"
	// Remember to change the img src and the alt title!!!!!!!!
	
	var blizzardClickCounter = 0
	var blizzardClickCounterMax = 3
	var portalClickCounter = 0
	var portalClickCounterMax = 5
	
	let clickedPathsBlizzardsPortals = []
	
	// Define connections tableData
	let tableData;
	Papa.parse(
	  DirectConnections,
	{
	  download: true,
	  header: true,
	  complete: function (results) {
	    // Assign parsed data to tableData
	    tableData = results.data;
	    // Remove zero-width space character from tableData
	    for (let i = 0; i < tableData.length; i++) {
	      for (let key in tableData[i]) {
		if (tableData[i].hasOwnProperty(key)) {
		  tableData[i][key] = tableData[i][key].replace(/\u200B/g, "");
		  }
		}
	      }
	      console.log(tableData);
	    },
	  }
	);

	// Define color dictionaries 
	const colorDictionary = {
	  1: "#eb3337",
	  2: "#fd8238",
	  3: "#fdf12c",
	  4: "#2ed14f",
	  5: "#2ca9f1",
	  6: "#4a51cc",
	  7: "#b948ba",
	  8: "#8b2c32",
	  9: "#5f5f5f",
	 10: "#377a46",
	 11: "#460055",
	 12: "#161616"
	};
	const colorDarktionary = {
	 1: "#761a1c",
	 2: "#7f411c",
	 3: "#7f7916",
	 4: "#176928",
	 5: "#165579",
	 6: "#252966",
	 7: "#5d245d",
	 8: "#461619",
	 9: "#303030",
	10: "#1c3d23",
	11: "#23002b",
	12: "#000000"
	};
	
	// Define csvData as a global variable
	var csvData;

	Papa.parse(
	  IndirectConnections,
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign the parsed data to the global csvData variable
	      csvData = results.data;
	    }
	  }
	);
	
// End of global variables
</script>

<script>
  // Load SVG
  let paths;
  let svgElement;
  var xhr = new XMLHttpRequest();
  xhr.open(
    "GET",
    SVG
  );
  xhr.onload = function () {
    if (xhr.status === 200) {
      var svg = xhr.responseText;
      var rangeElement = document.getElementById("range");
      rangeElement.innerHTML = svg;
      svgElement = rangeElement.querySelector("svg");
      paths = svgElement.querySelectorAll("path");
      paths.forEach(function (path) {
        path.setAttribute("fill", "transparent");
        path.setAttribute("stroke-opacity", "0");
      });
    }
  };
  xhr.send();
</script>

<script>
// Add blizzards
function addBlizzards() {
  var mouseoverHandler = function () {
    if (blizzardClickCounter < blizzardClickCounterMax && !clickedPathsBlizzardsPortals.includes(this.id)) {
      this.style.fill = "white";
    }
  };
  var mouseoutHandler = function () {
    this.style.fill = "transparent";
  };
  paths.forEach(function(path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
  });
  let clickedPaths = [];
  paths.forEach(function(path) {
    path.addEventListener("click", function() {
      // Check if blizzardClickCounter is less than blizzardClickCounterMax
      if (blizzardClickCounter >= blizzardClickCounterMax) {
        // If it is not, return early from the function
        return;
      }

      // Check if the clicked path has already been clicked during the addPortals phase
      if (clickedPathsBlizzardsPortals.includes(this.id)) {
        // If it has, do not perform any actions
        return;
      }

      // Log clicked path ID to console
      console.log(this.id);

      // Check if clickCounter is less than Max
      if (blizzardClickCounter < blizzardClickCounterMax) {
        // Create a clipPath element and set its id
        var clipPath = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "clipPath"
        );
        clipPath.setAttribute("id", "clip-" + this.id);

        // Clone the clicked path and append it to the clipPath
        var clonedPath = this.cloneNode(true);
        clipPath.appendChild(clonedPath);

        // Append the clipPath to the defs element
        var defs =
          svgElement.querySelector("defs") ||
          svgElement.insertBefore(
            document.createElementNS("http://www.w3.org/2000/svg", "defs"),
            svgElement.firstChild
          );
        defs.appendChild(clipPath);

        // Create an image element and set its attributes
        var image = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "image"
        );
        image.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "href",
          BlizzardPattern
        );
        image.setAttribute("width", "100%");
        image.setAttribute("height", "100%");
        image.setAttribute("clip-path", "url(#clip-" + this.id + ")");

        // Append the image to the SVG
        svgElement.appendChild(image);
        console.log(blizzardClickCounter);

        // Remove mouseover and mouseout event listeners
        this.removeEventListener("mouseover", mouseoverHandler);
        this.removeEventListener("mouseout", mouseoutHandler);
      }

      // Increment the click counter and push value to clickedPaths array
      blizzardClickCounter++;
      clickedPaths.push(this.id);
      clickedPathsBlizzardsPortals.push(this.id);

      // Find rows in table data where column A matches clicked path's ID
      const rows = tableData.filter((row) => clickedPaths.includes(row["A"]));

      // Find the row in table data where column A matches clicked path's ID
      const row = tableData.find((row) => row["A"] === this.id);

      // Remove everything in column B for that row
      if (row) {
        row["B"] = "";
      }

      // Remove all instances of clicked path's ID from column B
      tableData.forEach((row) => {
        if (row["B"]) {
          // Split the value in column B into an array of values
          let values = row["B"].split(",");
          // Filter out any values that are included in the clickedPaths array
          values = values.filter((value) => !clickedPaths.includes(value));
          // Join the remaining values back into a string and update the value in column B
          // Join the remaining values back into a string and update the value in column B
          row["B"] = values.join(",");
        }
      });

      if (blizzardClickCounter === blizzardClickCounterMax) {
        document.getElementById('button1').disabled = false;
        document.getElementById('button3').disabled = false;
      }
      // Update button text after each click
      updateButtonText();
    });
 });
}
</script>
	
<script>
// Add portals
function addPortals() {
  var mouseoverHandler = function () {
    if (portalClickCounter < portalClickCounterMax && !clickedPathsBlizzardsPortals.includes(this.id)) {
      this.style.fill = "white";
    }
  };
  var mouseoutHandler = function () {
    this.style.fill = "transparent";
  };
  paths.forEach(function(path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
  });
  let clickedPaths = [];
  paths.forEach(function(path) {
    path.addEventListener("click", function() {
      // Check if portalClickCounter is less than portalClickCounterMax
      if (portalClickCounter >= portalClickCounterMax) {
        // If it is not, return early from the function
        return;
      }

      // Check if the clicked path has already been clicked during the addBlizzards phase
      if (clickedPathsBlizzardsPortals.includes(this.id)) {
        // If it has, do not perform any actions
        return;
      }

      // Log clicked path ID to console
      console.log(this.id);

      // Check if clickCounter is less than Max
      if (portalClickCounter < portalClickCounterMax) {
        // Create an image element and set its attributes
        var image = document.createElementNS(
          "http://www.w3.org/2000/svg",
          "image"
        );
        image.setAttributeNS(
          "http://www.w3.org/1999/xlink",
          "href",
          "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/portal.png"
        );

        // Store the value of this.id in a variable
        var pathId = this.id;

        // Find matching row in CSV data
        var csvRow = csvData.find(function (row) {
          return row["Range"] === pathId;
        });

        // Get coordinates from CSV data
        var x = csvRow["Pixel Pair 1"];
        var y = csvRow["Pixel Pair 2"];

        // Set pointer-events attribute of the image element to none
        image.setAttribute("pointer-events", "none");

        // Append the image to the SVG
        svgElement.appendChild(image);

        // Add an event listener to the image element to update its x and y attributes after it has been loaded
        image.addEventListener("load", function() {
          // Get the bounding box of the image element
          var bbox = image.getBBox();

          // Update the x and y attributes of the image element to center it over the clicked area
          image.setAttribute("x", x - bbox.width / 2);
          image.setAttribute("y", y - bbox.height / 2);

          // Rotate the image a random number of degrees between 0 and 359 around its center point
          var angle = Math.floor(Math.random() * 360);
          var cx = x;
          var cy = y;
          image.setAttribute(
            "transform",
            "rotate(" + angle + " " + cx + " " + cy + ")"
          );
        });

        // Remove mouseover and mouseout event listeners from clicked path
        this.removeEventListener("mouseover", mouseoverHandler);
        this.removeEventListener("mouseout", mouseoutHandler);

        // Set fill color of clicked path to transparent
        this.style.fill = "transparent";
      }

      // Increment the click counter and push value to clickedPaths array
      portalClickCounter++;
      clickedPaths.push(this.id);
      clickedPathsBlizzardsPortals.push(this.id);

	if (portalClickCounter === portalClickCounterMax) {
	  // Update tableData
	  clickedPaths.forEach((clickedPath) => {
	    // Find the row in table data where column A matches clicked path's ID
	    const row = tableData.find((row) => row["A"] === clickedPath);
	    if (row) {
	      // Add all other clicked paths to column B for that row
	      const otherClickedPaths = clickedPaths.filter(
		(path) => path !== clickedPath
	      );
	      if (row["B"]) {
		row["B"] += "," + otherClickedPaths.join(",");
	      } else {
		row["B"] = otherClickedPaths.join(",");
	      }
	    }
	  });
	  document.getElementById('button1').disabled = false;
	  document.getElementById('button2').disabled = false;
	}

      // Update button text after each click
      updateButtonText();
    });
  });
}
</script>
	  
<script>
// Generate the map
function generateMap() {
  paths.forEach(function (path) {
    var clone = path.cloneNode(true);
    path.parentNode.replaceChild(clone, path);
  });

  // Recalculate columns L through P for all rows
  tableData.forEach((row) => {
    // Column M: vlookup col B values and add them + current value A and B
    row["M"] = ""; // initialize column M to blank
    if (row["B"] && row["B"].trim() !== "") {
      // check if column B is not empty or undefined
      const searchValues = row["B"].split(",");
      let searchResults = [];
      for (const searchValue of searchValues) {
        const trimmedSearchValue = searchValue.trim().replace(/\u200B/g, "");
        for (let i = 0; i < tableData.length; i++) {
          if (tableData[i]["A"] === trimmedSearchValue) {
            searchResults.push(tableData[i]["B"]);
            break;
          }
        }
      }
      row["M"] = [row["A"], row["B"], ...searchResults].join(",");
    }

    // Column N: Remove duplicate values from column M
    row["N"] = [...new Set(row["M"].split(","))]
      .filter((value) => value !== row["A"])
      .join(",");
	  
    // Column O: Count how many comma-separated values are in column B
    if (row["B"] && row["B"].trim() !== "") {
      // check if column B is not empty or undefined
      const values = row["B"].split(",");
      row["O"] = values.length;
    } else {
      row["O"] = 0;
    }

    // Column P: Count how many comma-separated values are in column N (unless it's empty, then set it to 0)
    if (row["N"] && row["N"].trim() !== "") {
      // check if column N is not empty or undefined
      const values = row["N"].split(",");
      row["P"] = values.length;
    } else {
      row["P"] = 0;
    }
  });

  // Log updated table data to console
  console.log(tableData);

  // Update the paths variable to reference the cloned paths
  paths = svgElement.querySelectorAll("path");

  // Set font size of indirect connections
  var fontSize = 30;

  // Color in the map and add indirect connections
  paths.forEach(function (path) {
    var pathId = path.getAttribute("id");
    for (var i = 0; i < tableData.length; i++) {
      if (tableData[i]["A"] === pathId) {
        // Color in the map
        var value = tableData[i]["O"];
        if (value >= 12) {
          value = 12;
        }
        if (value !== 0) {
          var color = colorDictionary[value];
          var border_color = colorDarktionary[value];
          path.style.setProperty("fill", color, "important");
          path.setAttribute("stroke-opacity", "100");
          path.style.setProperty("stroke", border_color, "important");
          path.style.setProperty("stroke-width", "2", "important");
        }

        // Add text to the specified location from CSV data
        value = tableData[i]["P"];
        if (value !== 0) {
          // Find matching row in CSV data
          var csvRow = csvData.find(function (row) {
            return row["Range"] === pathId;
          });

          // Get coordinates from CSV data
          var x = csvRow["Pixel Pair 1"];
          var y = csvRow["Pixel Pair 2"];

          var text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          text.setAttribute("x", x);
          text.setAttribute("y", y);
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("alignment-baseline", "middle");
          text.setAttribute("font-size", fontSize);
          text.setAttribute("font-weight", "bold");
	  if (tableData[i]["O"] >= 11) {
	    text.setAttribute("fill", "white");
	  } else {
	    text.setAttribute("fill", "black");
	  }
          text.textContent = value;

          // Adjust x and y coordinates to position midpoint of text at specified coordinates
          var bbox = text.getBBox();
          text.setAttribute("x", x - bbox.width / 2);
          text.setAttribute("y", y - bbox.height / 2);

          svgElement.appendChild(text);
        }
        break;
      }
    }
  });
	// Find the maximum value in column O
	var maxO = Math.max(...tableData.map((row) => row["O"]));

	// Create an image element and set its attributes
	var image = document.createElement("img");

	// Decide which image to display based on the maximum value in column O
	if (maxO == 4) {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_4.png";
	} else if (maxO == 5) {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_5.png";
	} else if (maxO == 6) {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_6.png";
	} else if (maxO == 7) {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_7.png";
	} else if (maxO == 8) {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_8.png";
	} else if (maxO == 9) {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_9.png";
	} else if (maxO == 10) {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_10.png";
	} else if (maxO == 11) {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_11.png";
	} else {
	  image.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ColorDict_12.png";
	}

	// Append the image to the body
	document.body.appendChild(image);

	// Wait for the image to load before setting its position
	image.addEventListener("load", function () {
	  // Get the position of the base image
	  var baseImage = document.getElementById("map");
	  var baseImageRect = baseImage.getBoundingClientRect();
	  var header = document.querySelector("header");
	  var headerHeight = header.offsetHeight;
	  var buttons = document.querySelector("div");
	  var buttonsHeight = buttons.offsetHeight;
		console.log(headerHeight)
		console.log(buttonsHeight)

	  // Set the position of the legend image relative to the bottom left corner of the base image
	  image.style.position = "absolute";
	  image.style.top = baseImageRect.bottom - image.height - headerHeight - buttonsHeight + 5 + "px";
	  image.style.left = baseImageRect.left + 5 + "px";
	});
	}
</script>
  
<script>
  var button_GenerateMap_clicked = false;
  var button_AddBlizzards_clicked = false;
  var button_AddPortals_clicked = false;
  function button_GenerateMap() {
    if (!button_GenerateMap_clicked) {
      button_GenerateMap_clicked = true;
      generateMap();
    }
  }
  function button_AddBlizzards() {
    if (!button_AddBlizzards_clicked && !button_GenerateMap_clicked) {
      button_AddBlizzards_clicked = true;
      addBlizzards();
      document.getElementById('button1').disabled = true;
      document.getElementById('button3').disabled = true;
    }
  }
  function button_AddPortals() {
    if (!button_AddPortals_clicked && !button_GenerateMap_clicked) {
      button_AddPortals_clicked = true;
      addPortals();
      document.getElementById('button1').disabled = true;
      document.getElementById('button2').disabled = true;
    }
  }
</script>

<script>
// Update button text on page load
updateButtonText();

function updateButtonText() {
    // Update "Add Blizzards" button text
    if (blizzardClickCounterMax - blizzardClickCounter <= 0) {
        document.getElementById("button2").innerHTML = "Added all Blizzards";
    } else {
        document.getElementById("button2").innerHTML = "Add Blizzards (" + (blizzardClickCounterMax - blizzardClickCounter) + " left)";
    }

    // Update "Add Portals" button text
    if (portalClickCounterMax - portalClickCounter <= 0) {
        document.getElementById("button3").innerHTML = "Added all Portals";
    } else {
        document.getElementById("button3").innerHTML = "Add Portals (" + (portalClickCounterMax - portalClickCounter) + " left)";
    }
}
</script>
</body>
</html>
