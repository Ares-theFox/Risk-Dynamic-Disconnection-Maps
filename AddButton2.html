<!DOCTYPE html>
<html>
  <head>
    <script src="jsnetworkx.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
    <script src="https://unpkg.com/cytoscape@3/dist/cytoscape.min.js"></script>
	  <script>console.log("aaaaaaaa")</script>
    <title>TESTING PAGE #2</title>
    <style>
      #map,
      #range {
        position: absolute;
      }
      #range {
        z-index: 1;
      }
      header {
        font-size: 35px;
        font-weight: bold;
      }
      header img {
        vertical-align: bottom;
      }
      #fontSizeInput {
        width: 35px;
      }
    </style>
	<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/all.min.css" integrity="sha512-1ycn6IcaQQ40/MKBW2W4Rhis/DbILU74C1vSrLJxCq57o941Ym01SwNsOMqvEBFlcgUa6xLiPY/NS5R+E6ztJQ==" crossorigin="anonymous" referrerpolicy="no-referrer" />
  </head>
  <body>
    <header>
	Supermax Prison Dynamic Disconnection Map 
	<img src="" />
        <span id="invalidText" style="color: red; font-style: italic; font-size: 20px;"></span>
    </header>
<div>
  <button id="zoomInButton"><i class="fas fa-search-plus"></i></button>
  <button id="blizzardButton" onclick="button_AddBlizzards()">Add Blizzards</button>
  <button id="eraserButton" onclick="eraser()">Eraser</button>
  <label for="fontSizeInput">Font Size:</label>
  <input type="number" id="fontSizeInput" name="fontSizeInput" value="30" min="1" max="100">
  <button id="stopButton" onclick="button_StopEditing()">Stop Editing</button>
</div>
<div>
  <button id="zoomOutButton"><i class="fas fa-search-minus"></i></button>
  <button id="portalButton" onclick="button_AddPortals()">Add Portals</button>
  <button id="undoButton" onclick="button_Undo()">Undo</button>
  <button id="resetButton">Reset Map</button>
  <button id="mapDirectoryButton">Map Directory</button>
  <div id="selectMenuContainer" style="display: inline-block;">
    <label for="centralityType">Centrality:</label>
    <select id="centralityType" name="centralityType">
      <option value="standard">Direct Connections</option>
      <option value="betweenness">Betweenness</option>
      <option value="eigenvector">Eigenvector</option>
      <option value="closeness">Closeness</option>
    </select>
  </div>
</div>
	<style>
	/* Add some basic styles to the button */
	button {
	font-size: 16px;
	padding: 8px 16px;
	border: none;
	cursor: pointer;
	}

	#blizzardButton {
	width: 180px;
	text-align: center;
	background-color: white;
	color: black;
	}

	#blizzardButton:hover {
	background-color: grey;
	}

	#portalButton {
	width: 180px;
	text-align: center;
	background-color: aqua;
	color: black;
	}

	#portalButton:hover {
	background-color: navy;
	color: white;
	}

	#eraserButton {
	width: 80px;
	text-align: center;
	background-color: #dd9d90;
	color: black;
	}

	#eraserButton:hover {
	background-color: #c89790;
	}
		
	#stopButton {
	background-color: white;
	color: white;
	}

	#stopButton:hover {
	background-color: white;
	}
		
	#undoButton {
	width: 80px;
	text-align: center;
	background-color: #d8482e;
	color: black;
	}

	#undoButton:hover {
	background-color: #c13e27;
	}

	#resetButton {
	width: 112px;
	text-align: center;
	background-color: grey;
	color: white;
	}

	#resetButton:hover {
	background-color: black;
	color: white;
	}

	#mapDirectoryButton {
	background-color: white;
	color: black;
	}

	#mapDirectoryButton:hover {
	background-color: grey;
	}
		
	#zoomInButton:hover {
	background-color: #ababab;
	}
		
	#zoomOutButton:hover {
	background-color: #ababab;
	}
	</style>
	  
    <img
      id="map"
      src="https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Supermax%20Prison.png"
      alt="Supermax Prison"
    />
    <div id="range"></div>
	  
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5"></script>
<script>
  let zoom = 1;
  document.getElementById("zoomInButton").addEventListener("click", function () {
    zoom += 0.1;
    document.body.style.zoom = zoom;
  });
  document.getElementById("zoomOutButton").addEventListener("click", function () {
    zoom -= 0.1;
    document.body.style.zoom = zoom;
  });
	
  document.getElementById("resetButton").addEventListener("click", function () {
    location.reload();
  });

// Get the button element
var mapDirectoryButton = document.getElementById("mapDirectoryButton");

// Add an event listener to the button that listens for the "click" event
mapDirectoryButton.addEventListener("click", function() {
  // Open the URL in a new tab when the button is clicked
  window.open("https://ares-thefox.github.io/Risk-Dynamic-Disconnection-Maps/", "_blank");
});

var images = [
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox1.PNG",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox2.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox3.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox4.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox5.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox6.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox7.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox8.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox9.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox10.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox11.png",
  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/ready_fox12.png"
];

// Preload the blizzard pattern
var blizzardPatternImage = new Image();
blizzardPatternImage.src = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/Supermax%20Prison%20blizzard%20pattern.png";

window.onload = function() {
  var img = document.querySelector("header img");
  var randomIndex = Math.floor(Math.random() * images.length);
  img.src = images[randomIndex];
};

// Define global variables
	// Define map-specific items
	var colorLegend = "Supermax%20Prison";
	var DirectConnections = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/" + colorLegend + "%20CSV.csv";
	var IndirectConnections = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/" + colorLegend + "%20Indirect%20Connection%20Locations%20CSV.csv";
	var SVG = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/" + colorLegend + "%20Paths.svg";
	var BlizzardPattern = blizzardPatternImage.src;
	// Remember to change the img src, blizzard pattern, and the alt title!!!!!!!!

	var totalBlizzards = 3
	var totalPortals = 5

	// Get the select menu container element
	var selectMenuContainer = document.getElementById("selectMenuContainer");

	// Hide the select menu container by default
	selectMenuContainer.style.display = "none";

	// Define a sequence of button presses
	var sequence = [
	  { button: "blizzardButton", count: totalBlizzards },
	  { button: "portalButton", count: totalPortals }
	];

	// Keep track of the current position in the sequence
	var sequenceIndex = 0;
	var sequenceCount = 0;

	// Add a flag to keep track of whether the sequence has been completed or not
	var sequenceCompleted = false;

	// Add event listeners to the buttons
	sequence.forEach(function (item) {
	  var button = document.getElementById(item.button);
	  var clickHandler = function () {
	    // Check if the sequence has been completed
	    if (sequenceCompleted) {
	      // If it has, remove the event listener for this button
	      button.removeEventListener("click", clickHandler);
	    } else {
	      if (item.button === sequence[sequenceIndex].button) {
		sequenceCount++;
		if (sequenceCount === item.count) {
		  sequenceIndex++;
		  sequenceCount = 0;
		}
	      } else {
		sequenceIndex = 0;
		sequenceCount = 0;
	      }

	      if (sequenceIndex === sequence.length) {
		selectMenuContainer.style.display = "";
		// Set the flag to true once the sequence is completed
		sequenceCompleted = true;
	      }
	    }
	  };

	  // Add the click event listener with the clickHandler function
	  button.addEventListener("click", clickHandler);
	});

	let blizzardArray = []
	let portalArray = []
	let clickedPathsBlizzardsPortals = []
	
	// Define connections tableData
	let tableData;
	let tableDataClone;
	Papa.parse(
	  DirectConnections,
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign parsed data to tableData
	      tableData = results.data;
	      // Remove zero-width space character from tableData
	      for (let i = 0; i < tableData.length; i++) {
		for (let key in tableData[i]) {
		  if (tableData[i].hasOwnProperty(key)) {
		    tableData[i][key] = tableData[i][key].replace(/\u200B/g, "");
		  }
		}
	      }
	      // Create a deep copy of tableData
	      tableDataClone = JSON.parse(JSON.stringify(tableData));
	    },
	  }
	);
	
	// Define color dictionaries 
	const colorDictionary = {
	  1: "#eb3337",
	  2: "#fd8238",
	  3: "#fdf12c",
	  4: "#2ed14f",
	  5: "#2ca9f1",
	  6: "#4a51cc",
	  7: "#b948ba",
	  8: "#8b2c32",
	  9: "#5f5f5f",
	 10: "#377a46",
	 11: "#460055",
	 12: "#161616"
	};
	const colorDarktionary = {
	 1: "#761a1c",
	 2: "#7f411c",
	 3: "#7f7916",
	 4: "#176928",
	 5: "#165579",
	 6: "#252966",
	 7: "#5d245d",
	 8: "#461619",
	 9: "#303030",
	10: "#1c3d23",
	11: "#23002b",
	12: "#000000"
	};
	
	// Define csvData as a global variable
	var csvData;
	
	// Define a counter variable to keep track of the number of requests that have completed
	var requestsCompleted = 0;
	
	// Define a function to call when a request has completed
	function onRequestComplete() {
	  requestsCompleted++;
	  if (requestsCompleted === 2) {
	    // Both requests have completed, so call the generateMap function
	    generateMap();
	  }
	}

	// Load the CSV data
	Papa.parse(
	  IndirectConnections,
	  {
	    download: true,
	    header: true,
	    complete: function (results) {
	      // Assign the parsed data to the global csvData variable
	      csvData = results.data;
	      // Call the onRequestComplete function to indicate that this request has completed
	      onRequestComplete();
	    }
	  }
	);

	// Define global variables
	centralityMenu = document.getElementById("centralityType");

	// Add an event listener to the menu element
	centralityMenu.addEventListener("change", function() {
	  generateMap();
	});
	
// End of global variables

	// Load the SVG
	let paths;
	let svgElement;
	var xhr = new XMLHttpRequest();
	xhr.open(
	  "GET",
	  SVG
	);
	xhr.onload = function () {
	  if (xhr.status === 200) {
	    var svg = xhr.responseText;
	    var rangeElement = document.getElementById("range");
	    rangeElement.innerHTML = svg;
	    svgElement = rangeElement.querySelector("svg");
	    paths = svgElement.querySelectorAll("path");
	    paths.forEach(function (path) {
	      path.setAttribute("fill", "transparent");
	      path.setAttribute("stroke-opacity", "0");
	    });
	    // Call the onRequestComplete function to indicate that this request has completed
	    onRequestComplete();
	  }
	};
	xhr.send();

// Stop editing
function stopEditing() {
	document.getElementById("stopButton").innerHTML = "Stop Editing";
	// Set the regular background color to white
	document.getElementById("stopButton").style.backgroundColor = "white";
	// Set the hover background color to white
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
	document.head.appendChild(styleElement);
	return;
}

// Centrality
function calculateCentrality(tableData) {
    // Create a list of unique territories
    let territories = [];
    for (let i = 0; i < tableData.length; i++) {
        if (tableData[i]['B'] !== '' && !territories.includes(tableData[i]['A'])) {
            territories.push(tableData[i]['A']);
        }
    }
    // Create an empty adjacency matrix
    let adjacencyMatrix = [];
    for (let i = 0; i < territories.length; i++) {
        adjacencyMatrix.push(new Array(territories.length).fill(0));
    }
    // Populate the adjacency matrix
    for (let i = 0; i < tableData.length; i++) {
        if (tableData[i]['B'] !== undefined && tableData[i]['B'] !== '') {
            let territory = tableData[i]['A'];
            let connections = tableData[i]['B'].split(',');
            for (let j = 0; j < connections.length; j++) {
                let connection = connections[j];
                if (connection !== '') {
                    let index1 = territories.indexOf(territory);
                    let index2 = territories.indexOf(connection);
                    adjacencyMatrix[index1][index2] = 1;
                }
            }
        }
    }

	// Create a graph from the adjacency matrix
	let elements = [];
	for (let i = 0; i < territories.length; i++) {
	    elements.push({ data: { id: territories[i] } });
	}
	
	// Check for invalid IDs
	for (let i = 0; i < elements.length; i++) {
	    if (elements[i].data.id === '') {
	        console.log('Invalid ID for element at index', i);
	    }
	}

    for (let i = 0; i < adjacencyMatrix.length; i++) {
        for (let j = 0; j < adjacencyMatrix.length; j++) {
            if (adjacencyMatrix[i][j] === 1) {
                elements.push({ data: { id: territories[i] + '-' + territories[j], source: territories[i], target: territories[j] } });
            }
        }
    }
    let cy = cytoscape({
        headless: true,
        elements: elements
    });

    // Calculate closeness centrality using Cytoscape.js
    let closenessCentralityValues = {};
    let closenessRank = {};

    cy.elements().closenessCentrality().closeness('#id').forEach(function(value, node) {
        closenessCentralityValues[node.id()] = value;
    });

    // Calculate rank values
    let uniqueClosenessValues = [...new Set(Object.values(closenessCentralityValues))].sort((a, b) => a - b);

    for (let key in closenessCentralityValues) {
        closenessRank[key] = uniqueClosenessValues.indexOf(closenessCentralityValues[key]) + 1;
    }

    // Round the centrality values
    for (let key in closenessCentralityValues) {
        closenessCentralityValues[key] = Math.round(closenessCentralityValues[key] * 1000) / 10;
    }

	// Create a graph from the adjacency matrix using jsnx
	let G = new jsnx.Graph();
	for (let i = 0; i < adjacencyMatrix.length; i++) {
		for (let j = i + 1; j < adjacencyMatrix.length; j++) {
			if (adjacencyMatrix[i][j] === 1) {
				G.addEdge(i, j);
			}
		}
	}

	// Calculate betweenness centrality and eigenvector centrality using jsnx
	let betweennessCentrality = jsnx.betweennessCentrality(G);
	let eigenvectorCentrality = jsnx.eigenvectorCentrality(G, {maxIter: 500});

	// Initialize values
	let betweennessCentralityValues = {};
	let betweennessRank = {};
	let eigenvectorCentralityValues = {};	
	let eigenvectorRank = {};
		
	// Get raw values
	for (let key in betweennessCentrality._numberValues) {
		betweennessCentralityValues[territories[key]] = betweennessCentrality._numberValues[key];
	}
	for (let key in eigenvectorCentrality._numberValues) {
		eigenvectorCentralityValues[territories[key]] = eigenvectorCentrality._numberValues[key];
	}

	// Calculate rank values
	let uniqueBetweennessValues = [...new Set(Object.values(betweennessCentralityValues))].sort((a, b) => a - b);
	let uniqueEigenvectorValues = [...new Set(Object.values(eigenvectorCentralityValues))].sort((a, b) => a - b);

	for (let key in betweennessCentralityValues) {
		betweennessRank[key] = uniqueBetweennessValues.indexOf(betweennessCentralityValues[key]) + 1;
	}
	
	for (let key in eigenvectorCentralityValues) {
		eigenvectorRank[key] = uniqueEigenvectorValues.indexOf(eigenvectorCentralityValues[key]) + 1;
	}

	// Round the centrality values
	for (let key in betweennessCentralityValues) {
		betweennessCentralityValues[key] = Math.round(betweennessCentralityValues[key] * 1000) / 10;
	}
	
	for (let key in eigenvectorCentralityValues) {
		eigenvectorCentralityValues[key] = Math.round(eigenvectorCentralityValues[key] * 1000) / 10;
	}

    return [betweennessCentralityValues, closenessCentralityValues, eigenvectorCentralityValues, betweennessRank, closenessRank, eigenvectorRank];
}

function closenessColor(closenessRank) {
    // Count the number of unique values in closenessRank
    let uniqueValues = new Set(Object.values(closenessRank)).size;

    // Generate a color dictionary with uniqueValues number of colors
    let closeness_colorDictionary = {};
    for (let i = 0; i < uniqueValues; i++) {
        let r = Math.round(255 - (255 - 204) * (i / (uniqueValues - 1)));
        let g = Math.round(255 - (255 - 0) * (i / (uniqueValues - 1)));
        let b = 0;
        let color = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
        closeness_colorDictionary[i + 1] = color;
    }

    return closeness_colorDictionary;
}

function closeness_borderColor(closenessRank) {
    // Count the number of unique values in closenessRank
    let uniqueValues = new Set(Object.values(closenessRank)).size;

    // Generate a color dictionary with uniqueValues number of colors
    let closeness_border_colorDictionary = {};
    for (let i = 0; i < uniqueValues; i++) {
        let r = Math.round(128 - (128 - 102) * (i / (uniqueValues - 1)));
        let g = Math.round(128 - (128 - 0) * (i / (uniqueValues - 1)));
        let b = 0;
        let color = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
        closeness_border_colorDictionary[i + 1] = color;
    }

    return closeness_border_colorDictionary;
}

function betweennessColor(betweennessRank) {
    // Count the number of unique values in betweennessRank
    let uniqueValues = new Set(Object.values(betweennessRank)).size;

    // Generate a color dictionary with uniqueValues number of colors
    let betweenness_colorDictionary = {};
    for (let i = 0; i < uniqueValues; i++) {
        let r = Math.round(255 - (255 - 204) * (i / (uniqueValues - 1)));
        let g = Math.round(255 - (255 - 0) * (i / (uniqueValues - 1)));
        let b = 0;
        let color = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
        betweenness_colorDictionary[i + 1] = color;
    }

    return betweenness_colorDictionary;
}

function betweenness_borderColor(betweennessRank) {
    // Count the number of unique values in betweennessRank
    let uniqueValues = new Set(Object.values(betweennessRank)).size;

    // Generate a color dictionary with uniqueValues number of colors
    let betweenness_border_colorDictionary = {};
    for (let i = 0; i < uniqueValues; i++) {
        let r = Math.round(128 - (128 - 102) * (i / (uniqueValues - 1)));
        let g = Math.round(128 - (128 - 0) * (i / (uniqueValues - 1)));
        let b = 0;
        let color = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
        betweenness_border_colorDictionary[i + 1] = color;
    }

    return betweenness_border_colorDictionary;
}

function eigenvectorColor(eigenvectorRank) {
    // Count the number of unique values in eigenvectorRank
    let uniqueValues = new Set(Object.values(eigenvectorRank)).size;

    // Generate a color dictionary with uniqueValues number of colors
    let eigenvector_colorDictionary = {};
    for (let i = 0; i < uniqueValues; i++) {
        let r = Math.round(255 - (255 - 204) * (i / (uniqueValues - 1)));
        let g = Math.round(255 - (255 - 0) * (i / (uniqueValues - 1)));
        let b = 0;
        let color = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
        eigenvector_colorDictionary[i + 1] = color;
    }

    return eigenvector_colorDictionary;
}

function eigenvector_borderColor(eigenvectorRank) {
    // Count the number of unique values in eigenvectorRank
    let uniqueValues = new Set(Object.values(eigenvectorRank)).size;

    // Generate a color dictionary with uniqueValues number of colors
    let eigenvector_border_colorDictionary = {};
    for (let i = 0; i < uniqueValues; i++) {
        let r = Math.round(128 - (128 - 102) * (i / (uniqueValues - 1)));
        let g = Math.round(128 - (128 - 0) * (i / (uniqueValues - 1)));
        let b = 0;
        let color = '#' + r.toString(16).padStart(2, '0') + g.toString(16).padStart(2, '0') + b.toString(16).padStart(2, '0');
        eigenvector_border_colorDictionary[i + 1] = color;
    }

    return eigenvector_border_colorDictionary;
}
	
// Generate the map
function generateMap() {
  // Update buttons
  updateButtonText();
  // Reset tableData to its original values
  tableData = JSON.parse(JSON.stringify(tableDataClone));
  // Remove existing text elements
  svgElement.querySelectorAll("text").forEach((text) => text.remove());
  // Remove everything contained in the blizzard array
	// Find rows in table data where column A matches values in blizzardArray
	const rows = tableData.filter((row) => blizzardArray.includes(row["A"]));

	// Remove everything in column B for those rows
	rows.forEach((row) => {
	  row["B"] = "";
	});

	// Remove all instances of values in blizzardArray from column B
	tableData.forEach((row) => {
	  if (row["B"]) {
	    // Split the value in column B into an array of values
	    let values = row["B"].split(",");
	    // Filter out any values that are included in the blizzardArray
	    values = values.filter((value) => !blizzardArray.includes(value));
	    // Join the remaining values back into a string and update the value in column B
	    row["B"] = values.join(",");
	  }
	});
  // Add everything contained in the portal array
	// Iterate over tableData
	tableData.forEach((row) => {
	  // Check if value in column A matches a value in portalArray
	  if (portalArray.includes(row["A"])) {
	    // Add contents of portalArray to column B
	    row["B"] = [
	      ...new Set([
		...(row["B"] ? row["B"].split(",") : []),
		...portalArray,
	      ]),
	    ]
	      .filter((value) => value !== row["A"])
	      .join(",");
	  }
	});
  // Recalculate columns L through P for all rows
  tableData.forEach((row) => {
    // Column M: vlookup col B values and add them + current value A and B
    row["M"] = ""; // initialize column M to blank
    if (row["B"] && row["B"].trim() !== "") {
      // check if column B is not empty or undefined
      const searchValues = row["B"].split(",");
      let searchResults = [];
      for (const searchValue of searchValues) {
        const trimmedSearchValue = searchValue.trim().replace(/\u200B/g, "");
        for (let i = 0; i < tableData.length; i++) {
          if (tableData[i]["A"] === trimmedSearchValue) {
            searchResults.push(tableData[i]["B"]);
            break;
          }
        }
      }
      row["M"] = [row["A"], row["B"], ...searchResults].join(",");
    }

    // Column N: Remove duplicate values from column M
    row["N"] = [...new Set(row["M"].split(","))]
      .filter((value) => value !== row["A"])
      .join(",");
	  
    // Column O: Count how many comma-separated values are in column B
    if (row["B"] && row["B"].trim() !== "") {
      // check if column B is not empty or undefined
      const values = row["B"].split(",");
      row["O"] = values.length;
    } else {
      row["O"] = 0;
    }

    // Column P: Count how many comma-separated values are in column N (unless it's empty, then set it to 0)
    if (row["N"] && row["N"].trim() !== "") {
      // check if column N is not empty or undefined
      const values = row["N"].split(",");
      row["P"] = values.length;
    } else {
      row["P"] = 0;
    }
  });

	// Calculate rescaled betweenness centrality and closeness centrality
	let [betweennessCentralityValues, eigenvectorCentralityValues, betweennessRank, eigenvectorRank] = calculateCentrality(tableData);
	let betweenness_ColorDictionary = betweennessColor(betweennessRank);
	let eigenvector_ColorDictionary = eigenvectorColor(eigenvectorRank);
	let betweenness_border_ColorDictionary = betweenness_borderColor(betweennessRank);
	let eigenvector_border_ColorDictionary = eigenvector_borderColor(eigenvectorRank);

	// Populate columns D, E, F, and G with the centrality values
	for (let i = 0; i < tableData.length; i++) {
	    let territory = tableData[i]['A'];
	    tableData[i]['D'] = betweennessCentralityValues[territory];
	    tableData[i]['E'] = betweennessRank[territory];
	    tableData[i]['F'] = eigenvectorCentralityValues[territory];
	    tableData[i]['G'] = eigenvectorRank[territory];
	    tableData[i]['H'] = closenessCentralityValues[territory];
	    tableData[i]['I'] = closenessRank[territory];
	}
	
  // Set font size of indirect connections
  var fontSizeInput = document.getElementById("fontSizeInput");
  fontSizeInput.addEventListener("input", function () {
    if (this.value > 100) {
      this.value = 100;
    } else if (this.value < 1) {
      this.value = 1;
    }
  });
  fontSizeInput.addEventListener("input", function() {
    debouncedGenerateMap();
  });

  // Color in the map and add indirect connections
  paths.forEach(function (path) {
    var pathId = path.getAttribute("id");
    for (var i = 0; i < tableData.length; i++) {
      if (tableData[i]["A"] === pathId) {
        // Color in the map
        var value = tableData[i]["O"];
	    var betweennessValue = tableData[i]["D"];
	    var betweennessPosition = tableData[i]["E"];
	    var eigenvectorValue = tableData[i]["F"];
	    var eigenvectorPosition = tableData[i]["G"];
	    var closenessValue = tableData[i]["H"];
	    var closenessPosition = tableData[i]["I"];
        if (value >= 12) {
          value = 12;
        }
        if (value !== 0) {
	  if (centralityMenu.value === "standard") {
	    var color = colorDictionary[value];
	    var border_color = colorDarktionary[value];
	  } else if (centralityMenu.value === "betweenness") {
	    var color = betweenness_ColorDictionary[betweennessPosition];
	    var border_color = betweenness_border_ColorDictionary[betweennessPosition];
	  } else if (centralityMenu.value === "eigenvector") {
	    var color = eigenvector_ColorDictionary[eigenvectorPosition];
	    var border_color = eigenvector_border_ColorDictionary[eigenvectorPosition];
	  } else if (centralityMenu.value === "closeness") {
	    var color = closeness_ColorDictionary[closenessPosition];
	    var border_color = closeness_border_ColorDictionary[closenessPosition];
	  }
          path.style.setProperty("fill", color, "important");
          path.setAttribute("stroke-opacity", "100");
          path.style.setProperty("stroke", border_color, "important");
          path.style.setProperty("stroke-width", "2", "important");
        }

        // Add text to the specified location from CSV data
        value = tableData[i]["P"];
        if (value !== 0) {
          // Find matching row in CSV data
          var csvRow = csvData.find(function (row) {
            return row["Range"] === pathId;
          });

          // Get coordinates from CSV data
          var x = csvRow["Pixel Pair 1"];
          var y = csvRow["Pixel Pair 2"];

          var text = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text"
          );
          text.setAttribute("x", x);
          text.setAttribute("y", y);
	  text.setAttribute("pointer-events", "none");
          text.setAttribute("text-anchor", "middle");
          text.setAttribute("alignment-baseline", "middle");
          text.setAttribute("font-size", fontSizeInput.value);
          text.setAttribute("font-weight", "bold");
	  if (tableData[i]["O"] >= 11) {
	    text.setAttribute("fill", "white");
	  } else {
	    text.setAttribute("fill", "black");
	  }
	  if (centralityMenu.value === "standard") {
	    text.textContent = value;
	  } else if (centralityMenu.value === "betweenness") {
	    text.textContent = betweennessValue;
	  } else if (centralityMenu.value === "eigenvector") {
	    text.textContent = eigenvectorValue;
	  } else if (centralityMenu.value === "closeness") {
	    text.textContent = closenessValue;
	  }
          // Adjust x and y coordinates to position midpoint of text at specified coordinates
          var bbox = text.getBBox();
          text.setAttribute("x", x - bbox.width / 2);
          text.setAttribute("y", y - bbox.height / 2);

          svgElement.appendChild(text);
        }
        break;
      }
    }
  });
	// Find the maximum value in column O
	var maxO = Math.max(...tableData.map((row) => row["O"]));

	// Ensure that maxO is never greater than 12
	if (maxO > 12) {
	  maxO = 12;
	}
	// Get the base image element & define base URL
	var baseImage = document.getElementById("map");
	var baseURL = "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/";

	// Decide which image to display based on the maximum value in column O
	if (maxO < 3) {
	    baseImage.src = baseURL + colorLegend + ".png";
	} else {
	    baseImage.src = baseURL + colorLegend + "%20" + maxO + ".png";
	}
	
// Create a mapping of node names to indices
let nodeToIndex = {};
let index = 0;
tableData.forEach(row => {
  if (row['A'] && !nodeToIndex.hasOwnProperty(row['A'])) {
    nodeToIndex[row['A']] = index++;
  }
  let neighbors = row['B'] ? row['B'].split(',') : [];
  neighbors.forEach(neighbor => {
    if (!nodeToIndex.hasOwnProperty(neighbor)) {
      nodeToIndex[neighbor] = index++;
    }
  });
});

// Create a distance matrix with dimensions equal to the number of nodes
let dist = new Array(index);
for (let i = 0; i < index; i++) {
  dist[i] = new Array(index);
  for (let j = 0; j < index; j++) {
    if (i === j) {
      dist[i][j] = 0;
    } else {
      dist[i][j] = Infinity;
    }
  }
}

// Populate the distance matrix with the distances between directly connected nodes
tableData.forEach(row => {
  let x = nodeToIndex[row['A']];
  let neighbors = row['B'] ? row['B'].split(',') : [];
  neighbors.forEach(neighbor => {
    let y = nodeToIndex[neighbor];
    dist[x][y] = 1;
    dist[y][x] = 1;
  });
});

// Run the Floyd-Warshall algorithm
for (let k = 0; k < index; k++) {
  for (let i = 0; i < index; i++) {
    for (let j = 0; j < index; j++) {
      if (dist[i][k] + dist[k][j] < dist[i][j]) {
        dist[i][j] = dist[i][k] + dist[k][j];
      }
    }
  }
}

// Check if there are any pairs of nodes that are not connected
let allNodesConnected = true;
for (let i = 0; i < index; i++) {
  for (let j = i + 1; j < index; j++) {
    // Get the node names corresponding to indices i and j
    let node1 = Object.keys(nodeToIndex).find(key => nodeToIndex[key] === i);
    let node2 = Object.keys(nodeToIndex).find(key => nodeToIndex[key] === j);
    // Check if either node is in the blizzardArray
    if (!blizzardArray.includes(node1) && !blizzardArray.includes(node2)) {
      // Check if the distance between the nodes is Infinity
      if (dist[i][j] === Infinity) {
        allNodesConnected = false;
        break;
      }
    }
  }
}

// Create a mapping of node names to indices for tableDataClone
let nodeToIndexClone = {};
let indexClone = 0;
tableDataClone.forEach(row => {
  if (row['A'] && !nodeToIndexClone.hasOwnProperty(row['A'])) {
    nodeToIndexClone[row['A']] = indexClone++;
  }
  let neighbors = row['B'] ? row['B'].split(',') : [];
  neighbors.forEach(neighbor => {
    if (!nodeToIndexClone.hasOwnProperty(neighbor)) {
      nodeToIndexClone[neighbor] = indexClone++;
    }
  });
});

// Create a distance matrix with dimensions equal to the number of nodes for tableDataClone
let distClone = new Array(indexClone);
for (let i = 0; i < indexClone; i++) {
  distClone[i] = new Array(indexClone);
  for (let j = 0; j < indexClone; j++) {
    if (i === j) {
      distClone[i][j] = 0;
    } else {
      distClone[i][j] = Infinity;
    }
  }
}

// Populate the distance matrix with the distances between directly connected nodes for tableDataCloneCopy
tableDataClone.forEach(row => {
  let x = nodeToIndexClone[row['A']];
  let neighbors = row['B'] ? row['B'].split(',') : [];
  neighbors.forEach(neighbor => {
    let y = nodeToIndexClone[neighbor];
    distClone[x][y] = 1;
    distClone[y][x] = 1;
  });
});

// Run the Floyd-Warshall algorithm for tableDataCloneCopy
for (let k = 0; k < indexClone; k++) {
  for (let i = 0; i < indexClone; i++) {
    for (let j = 0; j < indexClone; j++) {
      if (distClone[i][k] + distClone[k][j] < distClone[i][j]) {
        distClone[i][j] = distClone[i][k] + distClone[k][j];
      }
    }
  }
}

// Check if any pair of portal nodes are within 2 travel distance of each other
let portalsTooClose = false;
for (let i = 0; i < portalArray.length; i++) {
  for (let j = i + 1; j < portalArray.length; j++) {
    // Get the node names corresponding to indices i and j
    let node1 = portalArray[i];
    let node2 = portalArray[j];
    // Get the indices corresponding to the node names
    let x = nodeToIndexClone[node1];
    let y = nodeToIndexClone[node2];
    // Check if the distance between the nodes is less than or equal to 2
    if (distClone[x][y] <= 2) {
      portalsTooClose = true;
      break;
    }
  }
}

  // Check for too-small continents
  let continentCounts = {};
  tableData.forEach(row => {
    if (row['A'] && row['C']) {
      if (!continentCounts.hasOwnProperty(row['C'])) {
        continentCounts[row['C']] = 0;
      }
      continentCounts[row['C']]++;
    }
  });
  let blizzardContinentCounts = {};
  blizzardArray.forEach(path => {
    let row = tableData.find(row => row['A'] === path);
    if (row && row['C']) {
      if (!blizzardContinentCounts.hasOwnProperty(row['C'])) {
        blizzardContinentCounts[row['C']] = 0;
      }
      blizzardContinentCounts[row['C']]++;
    }
  });
  let continentTooSmall = false;
  for (let continent in continentCounts) {
    if (blizzardContinentCounts.hasOwnProperty(continent) && blizzardContinentCounts[continent] >= continentCounts[continent] - 1) {
      continentTooSmall = true;
      break;
    }
  }
  // Update invalid text
  var invalidText = document.getElementById("invalidText");
  if (!allNodesConnected && portalsTooClose && continentTooSmall) {
    invalidText.textContent = "Invalid Generation: Map disconnected; Portals too close; Continent too small";
  } else if (!allNodesConnected && portalsTooClose) {
    invalidText.textContent = "Invalid Generation: Map disconnected; Portals too close";
  } else if (!allNodesConnected && continentTooSmall) {
    invalidText.textContent = "Invalid Generation: Map disconnected; Continent too small";
  } else if (portalsTooClose && continentTooSmall) {
    invalidText.textContent = "Invalid Generation: Portals too close; Continent too small";
  } else if (!allNodesConnected) {
    invalidText.textContent = "Invalid Generation: Map is disconnected";
  } else if (portalsTooClose) {
    invalidText.textContent = "Invalid Generation: Portals are too close";
  } else if (continentTooSmall) {
    invalidText.textContent = "Invalid Generation: Continent too small";
  } else {
    invalidText.textContent = "";
  }
}
	
function debounce(func, wait) {
  let timeout;
  return function() {
    clearTimeout(timeout);
    timeout = setTimeout(() => func.apply(this, arguments), wait);
  };
}

const debouncedGenerateMap = debounce(generateMap, 500);

function addBlizzards() {
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Adding Blizzards";
	// Set the regular background color to green
	document.getElementById("stopButton").style.backgroundColor = "#4caf50";
	// Set the hover background color to dark green
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: #3e8e41 !important; }";
	document.head.appendChild(styleElement);

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

  // Check if size of blizzardArray is greater than or equal to totalBlizzards
  if (blizzardArray.length >= totalBlizzards) {
    // Return early from the function
    return;
  }
	// Define mouseover, mouseout, and click event handlers
	const mouseoverHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Change stroke color to white and stroke width to 3
	    this.style.setProperty("stroke", "white", "important");
	    this.style.setProperty("stroke-width", "3", "important");
	  }
	};
	const mouseoutHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Reset stroke color and width according to the color darktionary
	    let value = tableData.find(row => row['A'] === this.id)['O'];
	    if (value >= 12) {
	      value = 12;
	    }
	    let border_color = colorDarktionary[value];
	    this.style.setProperty("stroke", border_color, "important");
	    this.style.setProperty("stroke-width", "2", "important");
	  }
	};
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	// Create a clipPath element and set its id
	var clipPath = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "clipPath"
	);
	clipPath.setAttribute("id", "clip-" + this.id);

	// Clone the clicked path and append it to the clipPath
	var clonedPath = this.cloneNode(true);
	clipPath.appendChild(clonedPath);

	// Append the clipPath to the defs element
	var defs =
	  svgElement.querySelector("defs") ||
	  svgElement.insertBefore(
	    document.createElementNS("http://www.w3.org/2000/svg", "defs"),
	    svgElement.firstChild
	  );
	defs.appendChild(clipPath);

	// Create an image element and set its attributes
	var image = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "image"
	);
	image.setAttributeNS(
	  "http://www.w3.org/1999/xlink",
	  "href",
	  BlizzardPattern
	);
	image.setAttribute("width", "100%");
	image.setAttribute("height", "100%");
	image.setAttribute("clip-path", "url(#clip-" + this.id + ")");
	image.setAttribute("pointer-events", "none");

	// Append the image to the SVG
	svgElement.appendChild(image);

	// Move the image behind the path element
	svgElement.insertBefore(image, svgElement.firstChild);
	    
    // Add clicked path to arrays; push to history
    blizzardArray.push(this.id);
    clickedPathsBlizzardsPortals.push(this.id);
    history.push({ type: 'addBlizzard', pathId: this.id });
	    
    // Change the fill of the clicked path to transparent
    this.style.setProperty("fill", "transparent", "important");

    // Change stroke color and stroke width
    this.style.setProperty("stroke", "white", "important");
    this.style.setProperty("stroke-width", "1", "important");
	    
    // Check if size of blizzardArray is greater than or equal to totalBlizzards
    if (blizzardArray.length >= totalBlizzards) {
      // Remove existing event listeners from elements in paths array
      paths.forEach(function (path) {
        path.removeEventListener("mouseover", mouseoverHandler);
        path.removeEventListener("mouseout", mouseoutHandler);
        path.removeEventListener("click", clickHandler);
      });
      document.getElementById("stopButton").innerHTML = "Stop Editing";
	// Set the regular background color to white
	document.getElementById("stopButton").style.backgroundColor = "white";
	// Set the hover background color to white
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
	document.head.appendChild(styleElement);

      generateMap();
      return;
    }

    // Execute generateMap function
    generateMap();
    }
    };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}
	
function addBlizzards_pathID(pathID) {
  // Find the path element with the specified pathID
  let path = Array.from(paths).find((path) => path.getAttribute("id") === pathID);

  // Create a clipPath element and set its id
  var clipPath = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "clipPath"
  );
  clipPath.setAttribute("id", "clip-" + pathID);

  // Clone the clicked path and append it to the clipPath
  var clonedPath = path.cloneNode(true);
  clipPath.appendChild(clonedPath);

  // Append the clipPath to the defs element
  var defs =
    svgElement.querySelector("defs") ||
    svgElement.insertBefore(
      document.createElementNS("http://www.w3.org/2000/svg", "defs"),
      svgElement.firstChild
    );
  defs.appendChild(clipPath);

  // Create an image element and set its attributes
  var image = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "image"
  );
  image.setAttributeNS(
    "http://www.w3.org/1999/xlink",
    "href",
    BlizzardPattern
  );
  image.setAttribute("width", "100%");
  image.setAttribute("height", "100%");
  image.setAttribute("clip-path", "url(#clip-" + pathID + ")");
  image.setAttribute("pointer-events", "none");

  // Append the image to the SVG
  svgElement.appendChild(image);

  // Move the image behind the path element
  svgElement.insertBefore(image, svgElement.firstChild);

  // Add clicked path to arrays; push to history
  blizzardArray.push(pathID);
  clickedPathsBlizzardsPortals.push(pathID);
  
  // Change the fill of the clicked path to transparent
  path.style.setProperty("fill", "transparent", "important");

  // Change stroke color and stroke width
  path.style.setProperty("stroke", "white", "important");
  path.style.setProperty("stroke-width", "1", "important");

   // Execute generateMap function
   generateMap();
   return;
}

function addPortals() {
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Adding Portals";
	// Set the regular background color to green
	document.getElementById("stopButton").style.backgroundColor = "#4caf50";
	// Set the hover background color to dark green
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: #3e8e41 !important; }";
	document.head.appendChild(styleElement);

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

  // Check if size of portalArray is greater than or equal to totalPortals
  if (portalArray.length >= totalPortals) {
    // Return early from the function
    return;
  }
	// Define mouseover, mouseout, and click event handlers
	const mouseoverHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Change stroke color to white and stroke width to 3
	    this.style.setProperty("stroke", "white", "important");
	    this.style.setProperty("stroke-width", "3", "important");
	  }
	};
	const mouseoutHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Reset stroke color and width according to the color darktionary
	    let value = tableData.find(row => row['A'] === this.id)['O'];
	    if (value >= 12) {
	      value = 12;
	    }
	    let border_color = colorDarktionary[value];
	    this.style.setProperty("stroke", border_color, "important");
	    this.style.setProperty("stroke-width", "2", "important");
	  }
	};
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is NOT in clickedPathsBlizzardsPortals array
    if (!clickedPathsBlizzardsPortals.includes(this.id)) {
	// Create an image element and set its attributes
	var image = document.createElementNS(
	  "http://www.w3.org/2000/svg",
	  "image"
	);
	image.setAttributeNS(
	  "http://www.w3.org/1999/xlink",
	  "href",
	  "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/portal.png"
	);

	// Set a custom attribute to store the id of the clicked path
	image.setAttribute("data-path-id", this.id);

	// Store the value of this.id in a variable
	var pathId = this.id;

	// Find matching row in CSV data
	var csvRow = csvData.find(function (row) {
	  return row["Range"] === pathId;
	});

      // Get coordinates from CSV data
      var x = csvRow["Pixel Pair 1"];
      var y = csvRow["Pixel Pair 2"];

      // Set pointer-events attribute of the image element to none
      image.setAttribute("pointer-events", "none");

      // Append the image to the SVG
      svgElement.appendChild(image);

      // Add an event listener to the image element to update its x and y attributes after it has been loaded
      image.addEventListener("load", function() {
        // Get the bounding box of the image element
        var bbox = image.getBBox();

        // Update the x and y attributes of the image element to center it over the clicked area
        image.setAttribute("x", x - bbox.width / 2);
        image.setAttribute("y", y - bbox.height / 2);

        // Rotate the image a random number of degrees between 0 and 359 around its center point
        var angle = Math.floor(Math.random() * 360);
        var cx = x;
        var cy = y;
        image.setAttribute(
          "transform",
          "rotate(" + angle + " " + cx + " " + cy + ")"
        );
      });

      // Add clicked path to arrays; push to history
      portalArray.push(this.id);
      clickedPathsBlizzardsPortals.push(this.id);
      history.push({ type: 'addPortal', pathId: this.id });

       // Check if size of blizzardArray is greater than or equal to totalBlizzards
       if (portalArray.length >= totalPortals) {
         // Remove existing event listeners from elements in paths array
         paths.forEach(function (path) {
           path.removeEventListener("mouseover", mouseoverHandler);
           path.removeEventListener("mouseout", mouseoutHandler);
           path.removeEventListener("click", clickHandler);
         });
     	       document.getElementById("stopButton").innerHTML = "Stop Editing";
		// Set the regular background color to white
		document.getElementById("stopButton").style.backgroundColor = "white";
		// Set the hover background color to white
		var styleElement = document.createElement("style");
		styleElement.id = "stopButtonHoverStyle";
		styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
		document.head.appendChild(styleElement);

	       generateMap();
	       return;
       }

       // Execute generateMap function
       generateMap();
    }
  };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}

function button_StopEditing() {
  stopEditing();
}

function button_Undo() {
  undo();
}
	
function button_AddBlizzards() {
  addBlizzards();
}

function button_AddPortals() {
  addPortals();
}
	
function eraser() {
  // Immediately return if the size of the clickedPathsBlizzardsPortals array is empty
  if (clickedPathsBlizzardsPortals.length === 0) {
    return;
  }
  let shouldReturn = false;
  document.getElementById("stopButton").innerHTML = "Stop Erasing";
	// Set the regular background color to green
	document.getElementById("stopButton").style.backgroundColor = "#4caf50";
	// Set the hover background color to dark green
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: #3e8e41 !important; }";
	document.head.appendChild(styleElement);

  const blizzardButtonClick = function () {
    shouldReturn = true;
  };
  const portalButtonClick = function () {
    shouldReturn = true;
  };
  const eraserButtonClick = function () {
    shouldReturn = true;
  };
  const stopButtonClick = function () {
    shouldReturn = true;
  };
	
  document.getElementById("blizzardButton").addEventListener("click", blizzardButtonClick);
  document.getElementById("portalButton").addEventListener("click", portalButtonClick);
  document.getElementById("eraserButton").addEventListener("click", eraserButtonClick);
  document.getElementById("stopButton").addEventListener("click", stopButtonClick);

	// Define mouseover, mouseout, and click event handlers
	const mouseoverHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (clickedPathsBlizzardsPortals.includes(this.id)) {
	    // Change stroke color to #ff1111 and stroke width to 4
	    this.style.setProperty("stroke", "#ff1111", "important");
	    this.style.setProperty("stroke-width", "4", "important");
	  }
	};

	const mouseoutHandler = function () {
	  if (shouldReturn) {
	    return;
	  }
	  if (clickedPathsBlizzardsPortals.includes(this.id)) {
	    if (blizzardArray.includes(this.id)) {
	      // Change stroke color to white and stroke width to 3
	      this.style.setProperty("stroke", "white", "important");
	      this.style.setProperty("stroke-width", "1", "important");
	    } else if (portalArray.includes(this.id)) {
	      // Reset stroke color and width according to the color darktionary
	      let value = tableData.find(row => row['A'] === this.id)['O'];
	      if (value >= 12) {
		value = 12;
	      }
	      let border_color = colorDarktionary[value];
	      this.style.setProperty("stroke", border_color, "important");
	      this.style.setProperty("stroke-width", "2", "important");
	    }
	  }
	};
  const clickHandler = function () {
    if (shouldReturn) {
      return;
    }
    // Check if path is in clickedPathsBlizzardsPortals array
    if (clickedPathsBlizzardsPortals.includes(this.id)) {
      // Remove clicked path from clickedPathsBlizzardsPortals array
      clickedPathsBlizzardsPortals = clickedPathsBlizzardsPortals.filter(
        (path) => path !== this.id
      );

      // Check if path is in blizzardArray
      if (blizzardArray.includes(this.id)) {
        // Remove clicked path from blizzardArray; push to history
        blizzardArray = blizzardArray.filter((path) => path !== this.id);
	history.push({ type: 'eraseBlizzard', pathId: this.id });

        // Remove blizzard fill from clicked path
        var clipPathId = "blizzard-clip-" + this.id;
        var clipPath = document.getElementById(clipPathId);
        if (clipPath) {
          clipPath.remove();
        }
      }

      // Check if path is in portalArray
      if (portalArray.includes(this.id)) {
        // Remove clicked path from portalArray; push to history
        portalArray = portalArray.filter((path) => path !== this.id);
	history.push({ type: 'erasePortal', pathId: this.id });

        // Store the value of this.id in a variable
        var clickedPathId = this.id;

        // Remove portal image overlay from clicked path
        var images = svgElement.querySelectorAll("image");
        images.forEach(function (image) {
          // Check if the data-path-id attribute of the image matches the id of the clicked path
          if (image.getAttribute("data-path-id") === clickedPathId) {
            // Remove the image
            image.remove();
          }
        });
      }

      // Call generateMap function
      generateMap();

      // Check if clickedPathsBlizzardsPortals array is empty
      if (clickedPathsBlizzardsPortals.length === 0) {
	document.getElementById("stopButton").innerHTML = "Stop Editing";
	// Set the regular background color to white
	document.getElementById("stopButton").style.backgroundColor = "white";
	// Set the hover background color to white
	var styleElement = document.createElement("style");
	styleElement.id = "stopButtonHoverStyle";
	styleElement.textContent = "#stopButton:hover { background-color: white !important; }";
	document.head.appendChild(styleElement);
        return;
      }
    }
  };

  // Add event listeners to elements in paths array
  paths.forEach(function (path) {
    path.addEventListener("mouseover", mouseoverHandler);
    path.addEventListener("mouseout", mouseoutHandler);
    path.addEventListener("click", clickHandler);
  });
}

function addPortals_pathID(pathID) {
  // Find the path element with the specified pathID
  let path = Array.from(paths).find((path) => path.getAttribute("id") === pathID);

  // Create an image element and set its attributes
  var image = document.createElementNS(
    "http://www.w3.org/2000/svg",
    "image"
  );
  image.setAttributeNS(
    "http://www.w3.org/1999/xlink",
    "href",
    "https://raw.githubusercontent.com/Ares-theFox/Risk-Dynamic-Disconnection-Maps/main/portal.png"
  );

  // Set a custom attribute to store the id of the clicked path
  image.setAttribute("data-path-id", pathID);

  // Store the value of pathID in a variable
  var clickedPathId = pathID;

  // Find matching row in CSV data
  var csvRow = csvData.find(function (row) {
    return row["Range"] === clickedPathId;
  });

  // Get coordinates from CSV data
  var x = csvRow["Pixel Pair 1"];
  var y = csvRow["Pixel Pair 2"];

  // Set pointer-events attribute of the image element to none
  image.setAttribute("pointer-events", "none");

  // Append the image to the SVG
  svgElement.appendChild(image);

  // Add an event listener to the image element to update its x and y attributes after it has been loaded
  image.addEventListener("load", function () {
    // Get the bounding box of the image element
    var bbox = image.getBBox();

    // Update the x and y attributes of the image element to center it over the clicked area
    image.setAttribute("x", x - bbox.width / 2);
    image.setAttribute("y", y - bbox.height / 2);

    // Rotate the image a random number of degrees between 0 and 359 around its center point
    var angle = Math.floor(Math.random() * 360);
    var cx = x;
    var cy = y;
    image.setAttribute(
      "transform",
      "rotate(" + angle + " " + cx + " " + cy + ")"
    );
  });

   // Add clicked path to arrays; push to history
   portalArray.push(pathID);
   clickedPathsBlizzardsPortals.push(pathID);

   // Execute generateMap function
   generateMap();
   return;
}
	
// Update button text on page load
updateButtonText();

function updateButtonText() {
    // Update "Add Blizzards" button text
    if (totalBlizzards - blizzardArray.length <= 0) {
        document.getElementById("blizzardButton").innerHTML = "Added all Blizzards";
    } else {
        document.getElementById("blizzardButton").innerHTML = "Add Blizzards (" + (totalBlizzards - blizzardArray.length) + " left)";
    }

    // Update "Add Portals" button text
    if (totalPortals - portalArray.length <= 0) {
        document.getElementById("portalButton").innerHTML = "Added all Portals";
    } else {
        document.getElementById("portalButton").innerHTML = "Add Portals (" + (totalPortals - portalArray.length) + " left)";
    }
}

// Create an array to store the history of actions
let history = [];

// Add an event listener for the keydown event to the document object
document.addEventListener('keydown', function(event) {
  // Check if the ctrlKey property is true and if the key property is equal to 'z'
  if (event.ctrlKey && event.key === 'z') {
    // Call the undo function
    undo();
  }
});

function undo() {
  // Check if the history array is not empty
  if (history.length > 0) {
    // Get the last action from the history array
    let lastAction = history.pop();

    // Check the type of the last action
    if (lastAction.type === 'addBlizzard') {
      // Remove the last blizzard from the blizzardArray
      blizzardArray.pop();

      // Remove the last blizzard fill from the map
      let clipPathId = 'blizzard-clip-' + lastAction.pathId;
      let clipPath = document.getElementById(clipPathId);
      if (clipPath) {
        clipPath.remove();
      }

      // Remove the id of the undone path from the clickedPathsBlizzardsPortals array
      let index = clickedPathsBlizzardsPortals.indexOf(lastAction.pathId);
      if (index !== -1) {
        clickedPathsBlizzardsPortals.splice(index, 1);
      }
	  generateMap();
    } else if (lastAction.type === 'addPortal') {
      // Remove the last portal from the portalArray
      portalArray.pop();

      // Remove the last portal image from the map
      let images = svgElement.querySelectorAll('image');
      images.forEach(function(image) {
        // Check if the data-path-id attribute of the image matches the id of the last portal
        if (image.getAttribute('data-path-id') === lastAction.pathId) {
          // Remove the image
          image.remove();
        }
      });

      // Remove the id of the undone path from the clickedPathsBlizzardsPortals array
      let index = clickedPathsBlizzardsPortals.indexOf(lastAction.pathId);
      if (index !== -1) {
        clickedPathsBlizzardsPortals.splice(index, 1);
      }
	  generateMap();
    } else if (lastAction.type === 'eraseBlizzard') {
	  addBlizzards_pathID(lastAction.pathId);
    } else if (lastAction.type === 'erasePortal') {
	  addPortals_pathID(lastAction.pathId);
    }
  }
}
</script>
</body>
</html>
